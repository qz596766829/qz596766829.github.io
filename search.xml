<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IllegalArgumentException：argument type mismatch</title>
    <url>/2019/12/30/Bug-IdAutoException/</url>
    <content><![CDATA[<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>&ensp;&ensp;&ensp;&ensp;nested exception is org.apache.ibatis.reflection.ReflectionException: Could not set property ‘id’ of ‘class com.wzq.test.demo.entity.Fee’ with value ‘1211518556674199553’Cause:java.lang.IllegalArgumentException: argument type mismatch</p>
<a id="more"></a>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h4><pre><code>添加不传ID使用数据库中的自增。提示类型转换错误,Long转换Integer错误,原因ID初始化值过大转化成Integer错误。</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h4><pre><code>设置ID的初始化值:ALTER TABLE TABLENAME AUTO_INCREMENT=1;</code></pre>]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 Strams简单使用</title>
    <url>/2019/12/26/JDK8_strams/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><hr>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。<br>Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的上进行操作处理， 比如筛选， 排序，聚合等。<br>元素流在管道中经过中间的一系列操作（intermediate operation）和处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<a id="more"></a>
<h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 </li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><ol>
<li>场景一：过滤集合内的元素<blockquote>
<p>JDK8之前 对集合进行过滤</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; strList = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</span><br><span class="line">            System.out.println(<span class="string">"初始化数据： "</span> + strList);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * JDK8之前 对集合进行过滤</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//过滤掉小写字母c</span></span><br><span class="line">            strList = getFilterOutput(strList, <span class="string">"c"</span>);</span><br><span class="line">            System.out.println(<span class="string">"过滤小写字母c后数据："</span>+strList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 过滤掉小写字母c</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> strList   集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> strFilter 需要过滤的字符</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getFilterOutput</span><span class="params">(List&lt;String&gt; strList, String strFilter)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.equals(<span class="string">"c"</span>)) &#123;</span><br><span class="line">                    filterList.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filterList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>JDK8 后 使用Streams中 filter() and collect() 方法进行过滤数据和收集数据</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</span><br><span class="line">        System.out.println(<span class="string">"初始化数据： "</span> + strList);</span><br><span class="line">        strList = strList.stream().filter(s -&gt;</span><br><span class="line">                !s.equals(<span class="string">"c"</span>)</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">"过滤小写字母c后数据："</span> + strList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> strList.stream() : 将List转换为stram<br> filter() : 过滤并返回<br> collect() : 将返回的结果转换为List</p>
</blockquote>
</li>
<li>场景二：通过username获取对象<blockquote>
<p>JDK8 之前 通过username获取对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="string">"password1"</span>), <span class="keyword">new</span> User(<span class="string">"username2"</span>, <span class="string">"password2"</span>), <span class="keyword">new</span> User(<span class="string">"username3"</span>, <span class="string">"password3"</span>));</span><br><span class="line">        User user = getFilterUser(userList, <span class="string">"username2"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过username获取对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getFilterUser</span><span class="params">(List&lt;User&gt; userList,String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(user.getUsername()))&#123;</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK8 使用Streams中 filter(), findAny() and orElse() 方法进行过滤数据和收集数据</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="string">"password1"</span>), <span class="keyword">new</span> User(<span class="string">"username2"</span>, <span class="string">"password2"</span>), <span class="keyword">new</span> User(<span class="string">"username3"</span>, <span class="string">"password3"</span>));</span><br><span class="line">        User user = userList.stream().filter(username -&gt; <span class="string">"username2"</span>.equals(username)).findAny().orElse(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> filter() : 过滤并返回<br> findAny() : 若有返回参数，直接返回<br> orElse() : 若没有返回参数，返回null</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 之 单例模式</title>
    <url>/2019/12/26/designMode_singleton/</url>
    <content><![CDATA[<h4 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h4><p>&ensp;&ensp;&ensp;&ensp;Ensure a class has only one instance,and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
<h4 id="一个皇帝原则"><a href="#一个皇帝原则" class="headerlink" title="一个皇帝原则"></a>一个皇帝原则</h4><p>&ensp;&ensp;&ensp;&ensp;皇帝每天要上朝接待臣子、处理政务，臣子每天要叩拜皇帝，皇帝只能有一个，也就是一个类只能产生一个对象，该怎么实现呢？对象产生是通过new关键字完成的（当然也有其他方式，比如对象拷贝、反射等），这个怎么控制呀，但是大家别忘记了构造函数，使用new关键字创建对象时，都会根据输入的参数调用相应的构造函数，如果我们把构造函数设置为private私有访问权限不就可以禁止外部创建对象了吗？臣子叩拜唯一皇帝的过程如类图7-1所示。 </p>
<a id="more"></a>
<p><img src="https://img1.doubanio.com/view/ark_works_pic/common-largeshow/public/87117.jpg" alt="7-1"></p>
<p>&ensp;&ensp;&ensp;&ensp;图7-1 臣子叩拜皇帝类图</p>
<p>&ensp;&ensp;&ensp;&ensp;只有两个类，Emperor代表皇帝类，Minister代表臣子类，关联到皇帝类非常简单。Emperor如代码清单7-1所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-1 皇帝类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Emperor emperor = <span class="keyword">new</span> Emperor();<span class="comment">//初始化一个皇帝</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//世俗和道德约束你，目的就是不希望产生第二个皇帝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//皇帝发话了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我就是皇帝wuzq..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象，而Emperor自己则可以new一个对象出来，其他类对该类的访问都可以通过getInstance获得同一个对象。<br>&ensp;&ensp;&ensp;&ensp;皇帝有了，臣子要出场，其类如代码清单7-2所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-2 臣子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码清单7-2 臣子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day=<span class="number">0</span>;day&lt;<span class="number">3</span>;day++)&#123;</span><br><span class="line">            Emperor emperor = Emperor.getInstance();</span><br><span class="line">            <span class="comment">//打印一下地址,判断是否相同</span></span><br><span class="line">            System.out.println(emperor);</span><br><span class="line">            emperor.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">臣子参拜皇帝的运行结果如下所示。</span><br><span class="line">我就是皇帝wuzq...</span><br><span class="line">cn.wzq.design.mode.singleton.Emperor@<span class="number">299</span>a06ac</span><br><span class="line">我就是皇帝wuzq...</span><br><span class="line">cn.wzq.design.mode.singleton.Emperor@<span class="number">299</span>a06ac</span><br><span class="line">我就是皇帝wuzq...</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;臣子天天要上朝参见皇帝，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，老熟人了，容易讲话，这就是单例模式。</p>
<h4 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h4><p>&ensp;&ensp;&ensp;&ensp;单例模式（Singleton Pattern）是一个比较简单的模式，其定义如下：<br>&ensp;&ensp;&ensp;&ensp;Ensure a class has only one instance,and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
<p>&ensp;&ensp;&ensp;&ensp;单例模式的通用类图如图7-2所示</p>
<p><img src="https://img9.doubanio.com/view/ark_works_pic/common-largeshow/public/87326.jpg" alt="7-2"></p>
<p>&ensp;&ensp;&ensp;&ensp;如图7-2 单例模式通用类</p>
<p>&ensp;&ensp;&ensp;&ensp;Singleton类称为单例类，通过使用private的构造函数确保了在一个应用中只产生一个实例，并且是自行实例化的（在Singleton中自己使用new Singleton（））。</p>
<p>&ensp;&ensp;&ensp;&ensp;单例模式的通用源代码如代码清单7-3所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-3 单例模式通用代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Emperor emperor = <span class="keyword">new</span> Emperor();<span class="comment">//初始化一个皇帝</span></span><br><span class="line">    <span class="comment">//限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"皇帝要睡觉了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h4><h5 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h5><ul>
<li><p>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</p>
</li>
<li><p>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。</p>
</li>
<li><p>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</p>
</li>
<li><p>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</p>
<h5 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h5></li>
<li><p>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。</p>
</li>
<li><p>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</p>
</li>
<li><p>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</p>
<h5 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h5><p>&ensp;&ensp;&ensp;&ensp;在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反应”，可以采用单例模式，具体的场景如下：</p>
</li>
<li><p>要求生成唯一序列号的环境；</p>
</li>
<li><p>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</p>
</li>
<li><p>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</p>
</li>
<li><p>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。</p>
<h5 id="单例模式的注意事项"><a href="#单例模式的注意事项" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h5><p>&ensp;&ensp;&ensp;&ensp;首先，在高并发情况下，请注意单例模式的线程同步问题。单例模式有几种不同的实现方式，上面的例子不会出现产生多个实例的情况，但是如代码清单7-4所示的单例模式就需要考虑线程同步。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-4 线程不安全的单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;该单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则可能在内存中出现多个实例，破坏了最初的预期。为什么会出现这种情况呢？如一个线程A执行到singleton=new Singleton（），但还没有获得对象（对象初始化是需要时间的），第二个线程B也在执行，执行到（singleton==null）判断，那么线程B获得判断条件也是为真，于是继续运行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现两个对象！</p>
<p>&ensp;&ensp;&ensp;&ensp;解决线程不安全的方法有很多，可以在getSingleton方法前加synchronized关键字，也可以在getSingleton方法内增加synchronized来实现，但都不是最优秀的单例模式，建议读者使用如代码清单7-3所示的方式（有的书上把代码清单7-3中的单例称为饿汉式单例，在代码清单7-4中增加了synchronized的单例称为懒汉式单例）。</p>
<p>&ensp;&ensp;&ensp;&ensp;其次，需要考虑对象的复制情况。在Java中，对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。在一般情况下，类复制的情况不需要考虑，很少会出现一个单例类会主动要求被复制的情况，解决该问题的最好方法就是单例类不要实现Cloneable接口。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果一个类可以产生多个对象，对象的数量不受限制，则是非常容易实现的，直接使用new关键字就可以了，如果只要有一个对象，使用单例模式就可以了，但是如果要求一个类只能产生两三个对象呢？该怎么实现？我们还以皇帝为例来说明。</p>
<p>&ensp;&ensp;&ensp;&ensp;一般情况下，一个朝代的同一个时代只有一个皇帝，那有没有出现两个皇帝的情况呢？确实有，就出现在明朝，那三国期间的算不算？不算，各自称帝，各有各的地盘，国号不同。大家还记得《石灰吟》这首诗吗？作者是谁？于谦。他是被谁杀死的？明英宗朱祁镇。对，就是那个在土木堡之变中被瓦刺俘虏的皇帝，被俘虏后，他弟弟朱祁钰当上了皇帝，就是明景帝，估计刚当上皇帝乐疯了，忘记把他哥哥朱祁镇升级为太上皇，在那个时期就出现了两个皇帝，这期间的的大臣是非常郁闷的，为什么呀？因为可能出现今天参拜的皇帝和昨天的皇帝不相同，昨天给那个皇帝汇报，今天还要给这个皇帝汇报一遍，该情况的类图如图7-3所示。</p>
<p><img src="https://img3.doubanio.com/view/ark_works_pic/common-largeshow/public/87335.jpg" alt="7-3"></p>
<p>&ensp;&ensp;&ensp;&ensp;图7-3 多个皇帝类</p>
<p>&ensp;&ensp;&ensp;&ensp;这个类图看起来还算简单，但是实现就有点复杂了。Emperor类如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码清单7-5 固定数量的皇帝类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义最多能产生的实例数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxNumOfEmperor = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//定义一个列表，容纳所有的皇帝实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Emperor2&gt; emperorList = <span class="keyword">new</span> ArrayList&lt;Emperor2&gt;();</span><br><span class="line">    <span class="comment">//当前皇帝序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> countNumOfEmperor = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//产生所有的对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNumOfEmperor;i++)&#123;</span><br><span class="line">            emperorList.add(<span class="keyword">new</span> Emperor2(<span class="string">"皇帝"</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//皇帝名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        countNumOfEmperor = random.nextInt(maxNumOfEmperor);</span><br><span class="line">        <span class="keyword">return</span> emperorList.get(countNumOfEmperor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(nameList.get(countNumOfEmperor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在Emperor中使用了两个ArrayList分别存储实例和实例变量。当然，如果考虑到线程安全问题可以使用Vector来代替。臣子参拜皇帝的过程如代码清单7-6所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-6 臣子参拜皇帝的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义5个大臣</span></span><br><span class="line">        <span class="keyword">int</span> ministerNum=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ministerNum;i++) &#123;</span><br><span class="line">            Emperor2 emperor = Emperor2.getInstance();</span><br><span class="line">            System.out.print(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个大臣参拜的是："</span>+emperor);</span><br><span class="line">            emperor.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大臣参拜皇帝的结果如下所示。</span><br><span class="line">第<span class="number">1</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br><span class="line">第<span class="number">2</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br><span class="line">第<span class="number">3</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">6</span>bc168e5皇帝<span class="number">0</span></span><br><span class="line">第<span class="number">4</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">6</span>bc168e5皇帝<span class="number">0</span></span><br><span class="line">第<span class="number">5</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;看，果然每个大臣参拜的皇帝都可能不一样，大臣们就开始糊涂了，A大臣给皇1帝汇报了一件事情，皇2帝不知道，然后就开始怀疑大臣A是皇1帝的亲信，然后就想办法开始整……<br>这种需要产生固定数量对象的模式就叫做有上限的多例模式，它是单例模式的一种扩展，采用有上限的多例模式，我们可以在设计时决定在内存中有多少个实例，方便系统进行扩展，修正单例可能存在的性能问题，提供系统的响应速度。例如读取文件，我们可以在系统启动时完成初始化工作，在内存中启动固定数量的reader实例，然后在需要读取文件时就可以快速响应。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>&ensp;&ensp;&ensp;&ensp;单例模式是23个模式中比较简单的模式，应用也非常广泛，如在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理，等等。如果采用非单例模式（Prototype类型），则Bean初始化后的管理交由J2EE容器，Spring容器不再跟踪管理Bean的生命周期。</p>
<p>&ensp;&ensp;&ensp;&ensp;使用单例模式需要注意的一点就是JVM的垃圾回收机制，如果我们的一个单例对象在内存中长久不使用，JVM就认为这个对象是一个垃圾，在CPU资源空闲的情况下该对象会被清理掉，下次再调用时就需要重新产生一个对象。如果我们在应用中使用单例类作为有状态值（如计数器）的管理，则会出现恢复原状的情况，应用就会出现故障。如果确实需要采用单例模式来记录有状态的值，有两种办法可以解决该问题：</p>
<ul>
<li><p>由容器管理单例的生命周期</p>
<p>  Java EE容器或者框架级容器（如Spring）可以让对象长久驻留内存。当然，自行通过管理对象的生命期也是一个可行的办法，既然有那么多的工具提供给我们，为什么不用呢？</p>
</li>
<li><p>状态随时记录</p>
<p>  可以使用异步记录的方式，或者使用观察者模式，记录状态的变化，写入文件或写入数据库中，确保即使单例对象重新初始化也可以从资源环境获得销毁前的数据，避免应用数据丢失。</p>
</li>
</ul>
<h4 id="摘自：《设计模式之禅》-—-秦小波"><a href="#摘自：《设计模式之禅》-—-秦小波" class="headerlink" title="摘自：《设计模式之禅》 — 秦小波"></a>摘自：《设计模式之禅》 — 秦小波</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 方法引用</title>
    <url>/2019/12/25/JDK8_method/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<ul>
<li>方法引用：当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用</li>
<li>方法引用：在Lambda的基础上进一步的简化。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li>
<li>要求：实现接口的抽象方法体的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</li>
<li>使用操作符 :: 将类（或对象）与方法名分割开来</li>
<li>主要分为下面三种使用情况：<ol>
<li>对象 :: 实例方法名</li>
<li>类 :: 静态方法名</li>
<li>类 :: 实例方法名<a id="more"></a>
<h6 id="场景-模拟发送邮件"><a href="#场景-模拟发送邮件" class="headerlink" title="场景:模拟发送邮件"></a>场景:模拟发送邮件</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timingSendEamil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticEamil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" static 发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1、JDK8 之前</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> EmailService().timingSendEamil();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2、JDK8 后使用Lambda表达式优化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> EmailService().timingSendEamil();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3、因为方法引用是在Lambda的基础上进一步的简化,所以使用方法引用进一步优化上面的代码</span></span><br><span class="line"><span class="comment">         * 格式： 实例对象::实例方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EmailService emailService = <span class="keyword">new</span> EmailService();</span><br><span class="line">        <span class="keyword">new</span> Thread(emailService::timingSendEamil).start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4、拆分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runnable runnable = emailService::timingSendEamil;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 5、使用方法引用调用我们的静态方法</span></span><br><span class="line"><span class="comment">         * 格式: 类名::静态方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(EmailService::staticEamil).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6、使用方法引用调用构造方法</span></span><br><span class="line"><span class="comment">         * 格式： 类名::new</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(EmailService::<span class="keyword">new</span>).start();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 Lambda表达式</title>
    <url>/2019/12/25/JDK8_Lambda/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<ul>
<li>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</li>
<li>Lambda 允许把函数作为参数传递进方法中。</li>
<li>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</li>
<li>lambda表达式的重要特征:<ol>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。<a id="more"></a>
</li>
</ol>
</li>
</ul>
<hr>
<h6 id="JDK8-之前调用接口的方式是通过匿名内部类，调用接口中的方法。"><a href="#JDK8-之前调用接口的方式是通过匿名内部类，调用接口中的方法。" class="headerlink" title="JDK8 之前调用接口的方式是通过匿名内部类，调用接口中的方法。"></a>JDK8 之前调用接口的方式是通过匿名内部类，调用接口中的方法。</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface functionInterface = <span class="keyword">new</span> FunctionInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"get方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        functionInterface.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用Lambda表达式调用接口中的方法"><a href="#使用Lambda表达式调用接口中的方法" class="headerlink" title="使用Lambda表达式调用接口中的方法"></a>使用Lambda表达式调用接口中的方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface ft = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"JDK8 Lambda表达式调用：get方法"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        ft.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>() : 表示抽象方法所需的参数列表,(参数1，参数2)<br>-&gt; : 固定格式<br>{} ：表示抽象方法的方法体</p>
</blockquote>
<h6 id="有返回值的Lambda表达式调用方法"><a href="#有返回值的Lambda表达式调用方法" class="headerlink" title="有返回值的Lambda表达式调用方法"></a>有返回值的Lambda表达式调用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface2 functionInterface2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"有返回值的Lambda表达式调用方法"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(functionInterface2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 优化：有返回值的Lambda表达式调用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FunctionInterface2 functionInterface3 = () -&gt; <span class="string">"优化：有返回值的Lambda表达式调用方法"</span>;</span><br><span class="line">        System.out.println(functionInterface3.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="有参数，有返回值的Lambda表达式调用方法"><a href="#有参数，有返回值的Lambda表达式调用方法" class="headerlink" title="有参数，有返回值的Lambda表达式调用方法"></a>有参数，有返回值的Lambda表达式调用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface3</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface3 ft3 = (String s)-&gt; s;</span><br><span class="line">        System.out.println(ft3.get(<span class="string">"有参数，有返回值的Lambda表达式调用方法"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 函数接口</title>
    <url>/2019/12/25/JDK8_FunctionInterface/</url>
    <content><![CDATA[<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><blockquote>
<p>定义:接口中只有唯一的一个抽象方法，该接口就称之为函数接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>@FunctionInterface: <br/><br> JDK 8推出了一个重要的注解@FunctionInterface<br> @FunctionInterface:作用主要用来强制约定一个接口只允许一个抽象方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、使用@FunctionInterface注解后，该接口只能有一个抽象方法，</span></span><br><span class="line">    <span class="comment">//   get2() 方法放开会报错</span></span><br><span class="line">    <span class="comment">//void get2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数接口中支持 default 和 static 关键字修饰我们的方法，允许存在Object类中equals方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、使用@FunctionInterface注解后，该接口只能有一个抽象方法，</span></span><br><span class="line">    <span class="comment">//void get2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、函数接口中支持 default 和 static 关键字修饰我们的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是default修饰的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是static修饰的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、重点：允许存在Object类中equals方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK中存在的函数接口：<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;Runnable:用于创建线程 <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;Comparator:用于比较对象</p>
</blockquote>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 default关键字</title>
    <url>/2019/12/23/JDK8_default/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<br/></h3><ul>
<li>Jdk1.8之前的接口中只声明方法，方法具体实现应在子类中进行。<br/></li>
<li>Jdk1.8打破了这样的用法：接口中可以实现具体的方法体，只需要加上关键字static或者default修饰即可。<br/><a id="more"></a></li>
</ul>
<ol>
<li><p>default关键字</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    //自定义方法</span><br><span class="line">    void getUsername();</span><br><span class="line">    //默认方法</span><br><span class="line">    default void <span class="function"><span class="title">defaultUsername</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //默认方法,子类重写</span><br><span class="line">    default void <span class="function"><span class="title">overrideDefaultUsername</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">overrideDefaultUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        userService.getUsername();</span><br><span class="line">        userService.defaultUsername();</span><br><span class="line">        userService.overrideDefaultUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"结果打印数据："</span></span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername</span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername</span><br></pre></td></tr></table></figure>
</li>
<li><p>static关键字</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">void getUsername();</span><br><span class="line"></span><br><span class="line">default void <span class="function"><span class="title">defaultUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void <span class="function"><span class="title">overrideDefaultUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="function"><span class="title">staticUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;staticUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">overrideDefaultUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">在子类中发现不能重写被static关键字修饰的方法。</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        userService.getUsername();</span><br><span class="line">        userService.defaultUsername();</span><br><span class="line">        userService.overrideDefaultUsername();</span><br><span class="line">        UserService.staticUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"结果打印数据"</span></span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername</span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;staticUsername</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结<br>&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. detault关键字修饰的方法称为默认方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 子类可以选择性的是否重写该方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 接口中的default方法通过实例对象来调用<br>&nbsp;&nbsp;static:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. static关键字修饰的方法称为静态方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 子类不能重写该方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 接口中的静态方法通过接口名.方法名()的方式来</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
