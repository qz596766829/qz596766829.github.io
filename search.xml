<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>String equals()方法 源码分析</title>
    <url>/2020/01/06/String-equals/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ==:比较的引用类型，比较的是地址值是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123; <span class="comment">//地址值相等，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// instanceOf判断一个对象是不是某个类型的实例</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 比较每一个元素，只要有一个元素不想等 返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>总结：String equals()方法思路：先比较地址值是否相等，在比较字符串的长度是否相等，最后对每个字符做一一对应比较。</p>
</blockquote>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 源码分析</title>
    <url>/2020/01/02/SourceCode-ArrayList/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>ArrayList继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。如下图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/arraylist_jiegou.png" alt="ArrayList结构图"></p>
<a id="more"></a>
<ul>
<li>ArrayList 继承了AbstractList，实现了List。AbstractList、List提供了相关的添加、删除、修改、遍历等功能。</li>
<li>ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。在ArrayList中，我们即可以通过元素的序号快速获取元素对象,这就是快速随机访问。</li>
<li>ArrayList 实现了Cloneable接口，实现clone()，实现克隆。</li>
<li>ArrayList 实现java.io.Serializable接口，意味着ArrayList支持序列化，能通过序列化去传输。</li>
</ul>
<blockquote>
<p>扩展：ArrayList和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector。</p>
</blockquote>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> * 空数组，当用户创建空实例时，返回该数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> * 空数组实例</span></span><br><span class="line"><span class="comment"> * - 当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。</span></span><br><span class="line"><span class="comment"> * - 当用户第一次添加元素时，该数组将会扩容，变成默认容量为 10(DEFAULT_CAPACITY) 的一个数组===&gt;通过  ensureCapacityInternal() 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> * 数组对象</span></span><br><span class="line"><span class="comment"> * - 当前数据对象存放地方</span></span><br><span class="line"><span class="comment"> * - 当前对象不参与序列化</span></span><br><span class="line"><span class="comment"> * - transient 关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> * 数组中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个列表在结构上被修改的次数。结构修改是指改变列表的大小，或者以一种正在进行的迭代可能会保留不正确结果的方式扰乱列表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：size和elementData.length是不相同的。size是指当前集合中存在的元素个数，elementData.length是指当前集合指定的容量大小例如，如果我们ArrayList()时，ArrayList只是给我们默认的elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA,此时只是空数组，只有第一次add时才默认数组的大小为DEFAULT_CAPACITY=10 ，此时elementData.length=10,而size=0</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="ArrayList提供了三种构造方法："><a href="#ArrayList提供了三种构造方法：" class="headerlink" title="ArrayList提供了三种构造方法："></a>ArrayList提供了三种构造方法：</h4><h5 id="ArrayList-int-initialCapacity"><a href="#ArrayList-int-initialCapacity" class="headerlink" title="ArrayList(int initialCapacity)"></a>ArrayList(int initialCapacity)</h5><p>构造一个指定容量的ArrayList。这是一个带初始容量大小的有参构造函数。</p>
<ul>
<li>初始容量&gt;0：返回指定容量的大小</li>
<li>初始容量=0：返回空数组</li>
<li>初始容量&lt;0：抛出异常 IllegalArgumentException<!-- more -->
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> * - 构造一个指定容量的ArrayList。这是一个带初始容量大小的有参构造函数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * - 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> * - 如果指定的初始容量为负，抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList()"></a>ArrayList()</h5><p>无参构造方法，创建ArrayList对象的时候不传入参数，则使用此无参构造方法创建ArrayList对象。从前面知道DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的Object[]，给到elementData进行初始化，elementData也是个Object[]类型。<font color ="#CC0000">当有元素进行第一次添加 add() 时，elementData将会变成默认的长度10。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> * - 无参构造方法，创建ArrayList对象的时候不传入参数，则使用此无参构造方法创建ArrayList对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：默认容量为10，调用无参构造此时的容量0，当第一次调用 add() 方法时才进行扩容为10。    </p>
</blockquote>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/new_arraylist.png" alt=""></p>
<h5 id="ArrayList-Collection-lt-extends-E-gt-c"><a href="#ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a>ArrayList(Collection&lt;? extends E&gt; c)</h5><p>构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</p>
<ul>
<li>将 Collection 对象转换成数组并赋值给 elementData。</li>
<li>判断数组大小是否等于0，将空数组 EMPTY_ELEMENTDATA 赋值给 elementData。</li>
<li>如果size的值大于0，则执行Arrays.copy方法，把collection对象的内容(可以理解为深拷贝)拷贝到elementData中。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> * - 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * - 放入此列表的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> * - 如果集合为空，抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            // <span class="title">copyOf</span>(要复制的数组,要返回的副本的长度,要返回的副本的类)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="comment">// 将空数组 EMPTY_ELEMENTDATA 赋值给 elementData。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>总结：ArrayList 构造方法就是初始化存储数据容器。存储数据容器其本质就是数组，在ArrayList中叫elementData。</p>
</blockquote>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h5><p>将指定的元素添加此集合的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> * - 将指定的元素添加此集合的末尾。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查数组容量，不够，容器+1，</span></span><br><span class="line">    <span class="comment">// 注意：只+1，因为add()一次只添加一个元素，并且也能确保资源不被浪费。</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//添加对象，自增size 等同于 elementData[size]; size++;</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查数组容量，不够扩容。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 则取 DEFAULT_CAPACITY 和 minCapacity 的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数组容量，不够扩容。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//最小容量 &gt; 数组长度 = 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> * - 数组扩容，以确保它至少可以容纳由最小容量参数指定的元素数量。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// &gt;&gt;：表示右移，如果该数为正，则高位补0，若为负数，则高位补1</span></span><br><span class="line">    <span class="comment">// eg : 10 的二进制(1010) 右移 变成 0101(十进制5)，所以扩容是1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 拷贝数组，改变容量大小。</span></span><br><span class="line">    <span class="comment">// Arrays.copyof(原数组，新的数组长度)</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行大容量分配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果minCapacity&lt;0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 如果想要的容量大于MAX_ARRAY_SIZE，则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/add_1.png" alt=""></p>
<ol>
<li>第一次调用add方法流程分析<ol>
<li>调用 add() ,此时 size=0 ,size+1=1;</li>
<li>调用 ensureCapacityInternal(minCapacity) ,此时 minCapacity=1;</li>
<li>调用 calculateCapacity(elementData,minCapacity) ,此时 minCapacity=1 ,elementData={}, DEFAULT_CAPACITY=10 ,DEFAULTCAPACITY_EMPTY_ELEMENTDATA={};</li>
<li>因为 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 所以取 DEFAULT_CAPACITY ,minCapacity两数最大值 DEFAULT_CAPACITY;</li>
<li>返回 ensureCapacityInternal后,调用 ensureExplicitCapacity(minCapacity) ,此时 minCapacity=10, elementData.length=0;</li>
<li>因为 minCapacity - elementData.length &gt; 0调用 grow();</li>
<li>先扩容 newCapacity = newCapacity + ( newCapacity &gt;&gt; 1 )，判断 newCapacity - minCapacity &lt; 0，所以 newCapacity = minCapacity = 10;</li>
<li>拷贝数组，改变容量大小;</li>
<li>一并返回到 add(),添加对象，自增size;</li>
</ol>
</li>
</ol>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/add_2.jpg" alt=""></p>
<ol start="2">
<li>第二次扩容：第二次扩容是指当前集合中已经存在10(默认容量10)个元素后，继续添加第11个元素。<ol>
<li>调用 add() ,此时 size=10 ,size+1=11;</li>
<li>调用 ensureCapacityInternal(minCapacity) ,此时 minCapacity=11;</li>
<li>调用 calculateCapacity(elementData,minCapacity) ,此时 minCapacity=11 ,elementData.length=10, DEFAULT_CAPACITY=10 ,DEFAULTCAPACITY_EMPTY_ELEMENTDATA.length=0;</li>
<li>因为 elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA ,所以取 minCapacity=11;</li>
<li>返回 ensureCapacityInternal 后,调用 ensureExplicitCapacity(minCapacity) ,此时 minCapacity=11 ,elementData.length=10;</li>
<li>因为 minCapacity - elementData.length &gt; 0 调用 grow();</li>
<li>先扩容 newCapacity = newCapacity + ( newCapacity &gt;&gt; 1 ) ，判断 newCapacity - minCapacity &gt; 0，所以 newCapacity = newCapacity = 15;</li>
<li>拷贝数组，改变容量大小;</li>
<li>一并返回到add(),添加对象，自增size;</li>
</ol>
</li>
</ol>
<h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><p>指定元素插入到列表中的指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> * - 将指定元素插入到列表中的指定位置。将当前位于该位置的元素(如果有)和任何后续元素向右移动(将一个元素添加到它们的索引中)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * - 要插入指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * - 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * - 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 检查数组容量，不够，扩容</span></span><br><span class="line">    <span class="comment">// 注意：只+1，因为add()一次只添加一个元素，并且也能确保资源不被浪费。</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// System.arraycopy(源数组，源数组起始索引，目标数组，目标数组起始索引，要拷贝的长度)</span></span><br><span class="line">    <span class="comment">// 主要思想：将当前位于该位置的元素(如果有)和任何后续元素向右移动(将一个元素添加到它们的索引中)。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 指定索引位置赋值   </span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 大小+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A version of rangeCheck used by add and addAll.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要插入的索引位置不能小于0，不能大于size</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：add(int index, E element)先检查索引是否越界，再判断是否需要扩容，再将需要右移的元素右移，最后赋值，修改大小。</p>
</blockquote>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><p>删除列表中指定位置的元素。将后续所有元素向左移动(从它们的索引中减去1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> * - 删除列表中指定位置的元素。将后续所有元素向左移动(从它们的索引中减去1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * - 指定要删除的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * - 删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * - 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要思想：</span></span><br><span class="line">    <span class="comment">// - 1. 先计算出需要左移的元素长度</span></span><br><span class="line">    <span class="comment">// - 2. 将后续所有元素向左移动(从它们的索引中减去1)。</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// System.arraycopy(源数组，源数组起始索引，目标数组，目标数组起始索引，要拷贝的长度)</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 左移后，将最后一个元素至空</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回删除的元素值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if the given index is in range.  If not, throws an appropriate</span></span><br><span class="line"><span class="comment"> * runtime exception.  This method does *not* check if the index is</span></span><br><span class="line"><span class="comment"> * negative: It is always used immediately prior to an array access,</span></span><br><span class="line"><span class="comment"> * which throws an ArrayIndexOutOfBoundsException if index is negative.</span></span><br><span class="line"><span class="comment"> * - 检查给定的索引是否在范围内。如果不是，则抛出适当的运行时异常。该方法不*not*检查索引是否为负数:它总是在数组访问之前使用，如果索引为负数，则会抛出ArrayIndexOutOfBoundsException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an IndexOutOfBoundsException detail message.</span></span><br><span class="line"><span class="comment"> * Of the many possible refactorings of the error handling code,</span></span><br><span class="line"><span class="comment"> * this "outlining" performs best with both server and client VMs.</span></span><br><span class="line"><span class="comment"> * - 构造一个角标越界提示信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定索引的值</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：remove(int index)先检查索引是否越界，然后计算出要左移的元素长度，最后左移。将最后一个元素至空。</p>
</blockquote>
<h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><p>从该列表中删除指定元素的第一个匹配项(如果存在)。如果列表不包含该元素，它将保持不变。确切的说，删除索引最小的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * - 从该列表中删除指定元素的第一个匹配项(如果存在)。如果列表不包含该元素，它将保持不变。确切的说，删除索引最小的元素</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ?  get(i) == null : o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * - 要删除的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> * - 返回true or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> * - 私有移除方法，该方法跳过边界检查且不返回被移除的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算要左移元素的长度</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// System.arraycopy(源数组，源数组起始索引，目标数组，目标数组起始索引，要拷贝的长度)</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 左移后，将最后一个元素至空</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：remove(Object o)：删除指定元素，不用检查索引越界。此方法只删除索引值最小的元素。</p>
</blockquote>
<h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><p>返回列表中指定位置的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * - 返回列表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 获取指定索引上的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><p>将列表中指定位置的元素替换为指定元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment"> * the specified element.</span></span><br><span class="line"><span class="comment"> * - 将列表中指定位置的元素替换为指定元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * - 要替换的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * - 元素存储在指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * - 先前位于指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 获取指定位置的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 替换指定位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回被替换的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf(Object o)"></a>indexOf(Object o)</h4><p>返回该列表中指定元素第一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最低的索引的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * - 返回该列表中指定元素第一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最低的索引的元素</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf(Object o)"></a>lastIndexOf(Object o)</h4><p>返回指定元素最后一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最高的索引的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * - 返回指定元素最后一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最高的索引的元素</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>从列表中删除所有元素。该调用返回后，列表将为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> * - 从列表中删除所有元素。该调用返回后，列表将为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>IllegalArgumentException：argument type mismatch</title>
    <url>/2019/12/30/Bug-IdAutoException/</url>
    <content><![CDATA[<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nested exception is org.apache.ibatis.reflection.ReflectionException: Could not set property <span class="string">'id'</span> of <span class="string">'class com.wzq.test.demo.entity.Fee'</span> with value <span class="string">'1211518556674199553'</span>Cause:java.lang.IllegalArgumentException: argument type mismatch</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h4><pre><code>添加不传ID使用数据库中的自增。提示类型转换错误,Long转换Integer错误,原因ID初始化值过大转化成Integer错误。</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h4><pre><code>设置ID的初始化值:ALTER TABLE TABLENAME AUTO_INCREMENT=1;
@TableId(value = &quot;id&quot;, type = IdType.AUTO)
private Integer id;</code></pre>]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 Strams简单使用</title>
    <url>/2019/12/26/JDK8_strams/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><hr>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。<br>Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的上进行操作处理， 比如筛选， 排序，聚合等。<br>元素流在管道中经过中间的一系列操作（intermediate operation）和处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<a id="more"></a>
<h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 </li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><ol>
<li>场景一：过滤集合内的元素<blockquote>
<p>JDK8之前 对集合进行过滤</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; strList = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</span><br><span class="line">            System.out.println(<span class="string">"初始化数据： "</span> + strList);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * JDK8之前 对集合进行过滤</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//过滤掉小写字母c</span></span><br><span class="line">            strList = getFilterOutput(strList, <span class="string">"c"</span>);</span><br><span class="line">            System.out.println(<span class="string">"过滤小写字母c后数据："</span>+strList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 过滤掉小写字母c</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> strList   集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> strFilter 需要过滤的字符</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getFilterOutput</span><span class="params">(List&lt;String&gt; strList, String strFilter)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.equals(<span class="string">"c"</span>)) &#123;</span><br><span class="line">                    filterList.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filterList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8 后 使用Streams中 filter() and collect() 方法进行过滤数据和收集数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</span><br><span class="line">        System.out.println(<span class="string">"初始化数据： "</span> + strList);</span><br><span class="line">        strList = strList.stream().filter(s -&gt;</span><br><span class="line">                !s.equals(<span class="string">"c"</span>)</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">"过滤小写字母c后数据："</span> + strList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 strList.stream() : 将List转换为stram<br> filter() : 过滤并返回<br> collect() : 将返回的结果转换为List</li>
<li>场景二：通过username获取对象<blockquote>
<p>JDK8 之前 通过username获取对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="string">"password1"</span>), <span class="keyword">new</span> User(<span class="string">"username2"</span>, <span class="string">"password2"</span>), <span class="keyword">new</span> User(<span class="string">"username3"</span>, <span class="string">"password3"</span>));</span><br><span class="line">        User user = getFilterUser(userList, <span class="string">"username2"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过username获取对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getFilterUser</span><span class="params">(List&lt;User&gt; userList,String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(user.getUsername()))&#123;</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8 使用Streams中 filter(), findAny() and orElse() 方法进行过滤数据和收集数据</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="string">"password1"</span>), <span class="keyword">new</span> User(<span class="string">"username2"</span>, <span class="string">"password2"</span>), <span class="keyword">new</span> User(<span class="string">"username3"</span>, <span class="string">"password3"</span>));</span><br><span class="line">        User user = userList.stream().filter(username -&gt; <span class="string">"username2"</span>.equals(username)).findAny().orElse(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>filter() : 过滤并返回
findAny() : 若有返回参数，直接返回
orElse() : 若没有返回参数，返回null</code></pre><ol start="3">
<li>场景三：从对象集合中取出某个字段的集合<blockquote>
<p>JDK 8 之前从对象集合中取出某个字段的集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义list集合</span></span><br><span class="line">        List&lt;admin&gt; list = Arrays.asList(<span class="keyword">new</span> admin(<span class="number">1</span>, <span class="string">"周杰"</span>), <span class="keyword">new</span> admin(<span class="number">2</span>, <span class="string">"周捷"</span>), <span class="keyword">new</span> admin(<span class="number">3</span>, <span class="string">"周洁"</span>));</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (admin admin : list) &#123;</span><br><span class="line">            names.add(admin.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">admin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8 使用Streams中 map(), collect()方法进行过滤数据和收集数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义list集合</span></span><br><span class="line">        List&lt;admin&gt; list = Arrays.asList(<span class="keyword">new</span> admin(<span class="number">1</span>, <span class="string">"周杰"</span>), <span class="keyword">new</span> admin(<span class="number">2</span>, <span class="string">"周捷"</span>), <span class="keyword">new</span> admin(<span class="number">3</span>, <span class="string">"周洁"</span>));</span><br><span class="line">        <span class="comment">//从list集合中，取出字段name的列表</span></span><br><span class="line">        List&lt;String&gt; names = list.stream().map(p -&gt; p.getName()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">admin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 之 单例模式</title>
    <url>/2019/12/26/designMode_singleton/</url>
    <content><![CDATA[<h4 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h4><p>&ensp;&ensp;&ensp;&ensp;Ensure a class has only one instance,and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
<h4 id="一个皇帝原则"><a href="#一个皇帝原则" class="headerlink" title="一个皇帝原则"></a>一个皇帝原则</h4><p>&ensp;&ensp;&ensp;&ensp;皇帝每天要上朝接待臣子、处理政务，臣子每天要叩拜皇帝，皇帝只能有一个，也就是一个类只能产生一个对象，该怎么实现呢？对象产生是通过new关键字完成的（当然也有其他方式，比如对象拷贝、反射等），这个怎么控制呀，但是大家别忘记了构造函数，使用new关键字创建对象时，都会根据输入的参数调用相应的构造函数，如果我们把构造函数设置为private私有访问权限不就可以禁止外部创建对象了吗？臣子叩拜唯一皇帝的过程如类图7-1所示。 </p>
<a id="more"></a>
<p><img src="https://img1.doubanio.com/view/ark_works_pic/common-largeshow/public/87117.jpg" alt="7-1"></p>
<p>&ensp;&ensp;&ensp;&ensp;图7-1 臣子叩拜皇帝类图</p>
<p>&ensp;&ensp;&ensp;&ensp;只有两个类，Emperor代表皇帝类，Minister代表臣子类，关联到皇帝类非常简单。Emperor如代码清单7-1所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-1 皇帝类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Emperor emperor = <span class="keyword">new</span> Emperor();<span class="comment">//初始化一个皇帝</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//世俗和道德约束你，目的就是不希望产生第二个皇帝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//皇帝发话了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我就是皇帝wuzq..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象，而Emperor自己则可以new一个对象出来，其他类对该类的访问都可以通过getInstance获得同一个对象。<br>&ensp;&ensp;&ensp;&ensp;皇帝有了，臣子要出场，其类如代码清单7-2所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-2 臣子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码清单7-2 臣子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day=<span class="number">0</span>;day&lt;<span class="number">3</span>;day++)&#123;</span><br><span class="line">            Emperor emperor = Emperor.getInstance();</span><br><span class="line">            <span class="comment">//打印一下地址,判断是否相同</span></span><br><span class="line">            System.out.println(emperor);</span><br><span class="line">            emperor.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">臣子参拜皇帝的运行结果如下所示。</span><br><span class="line">我就是皇帝wuzq...</span><br><span class="line">cn.wzq.design.mode.singleton.Emperor@<span class="number">299</span>a06ac</span><br><span class="line">我就是皇帝wuzq...</span><br><span class="line">cn.wzq.design.mode.singleton.Emperor@<span class="number">299</span>a06ac</span><br><span class="line">我就是皇帝wuzq...</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;臣子天天要上朝参见皇帝，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，老熟人了，容易讲话，这就是单例模式。</p>
<h4 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h4><p>&ensp;&ensp;&ensp;&ensp;单例模式（Singleton Pattern）是一个比较简单的模式，其定义如下：<br>&ensp;&ensp;&ensp;&ensp;Ensure a class has only one instance,and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
<p>&ensp;&ensp;&ensp;&ensp;单例模式的通用类图如图7-2所示</p>
<p><img src="https://img9.doubanio.com/view/ark_works_pic/common-largeshow/public/87326.jpg" alt="7-2"></p>
<p>&ensp;&ensp;&ensp;&ensp;如图7-2 单例模式通用类</p>
<p>&ensp;&ensp;&ensp;&ensp;Singleton类称为单例类，通过使用private的构造函数确保了在一个应用中只产生一个实例，并且是自行实例化的（在Singleton中自己使用new Singleton（））。</p>
<p>&ensp;&ensp;&ensp;&ensp;单例模式的通用源代码如代码清单7-3所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-3 单例模式通用代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Emperor emperor = <span class="keyword">new</span> Emperor();<span class="comment">//初始化一个皇帝</span></span><br><span class="line">    <span class="comment">//限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"皇帝要睡觉了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h4><h5 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h5><ul>
<li><p>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</p>
</li>
<li><p>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。</p>
</li>
<li><p>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</p>
</li>
<li><p>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</p>
<h5 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h5></li>
<li><p>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。</p>
</li>
<li><p>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</p>
</li>
<li><p>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</p>
<h5 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h5><p>&ensp;&ensp;&ensp;&ensp;在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反应”，可以采用单例模式，具体的场景如下：</p>
</li>
<li><p>要求生成唯一序列号的环境；</p>
</li>
<li><p>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</p>
</li>
<li><p>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</p>
</li>
<li><p>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。</p>
<h5 id="单例模式的注意事项"><a href="#单例模式的注意事项" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h5><p>&ensp;&ensp;&ensp;&ensp;首先，在高并发情况下，请注意单例模式的线程同步问题。单例模式有几种不同的实现方式，上面的例子不会出现产生多个实例的情况，但是如代码清单7-4所示的单例模式就需要考虑线程同步。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-4 线程不安全的单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;该单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则可能在内存中出现多个实例，破坏了最初的预期。为什么会出现这种情况呢？如一个线程A执行到singleton=new Singleton（），但还没有获得对象（对象初始化是需要时间的），第二个线程B也在执行，执行到（singleton==null）判断，那么线程B获得判断条件也是为真，于是继续运行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现两个对象！</p>
<p>&ensp;&ensp;&ensp;&ensp;解决线程不安全的方法有很多，可以在getSingleton方法前加synchronized关键字，也可以在getSingleton方法内增加synchronized来实现，但都不是最优秀的单例模式，建议读者使用如代码清单7-3所示的方式（有的书上把代码清单7-3中的单例称为饿汉式单例，在代码清单7-4中增加了synchronized的单例称为懒汉式单例）。</p>
<p>&ensp;&ensp;&ensp;&ensp;其次，需要考虑对象的复制情况。在Java中，对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。在一般情况下，类复制的情况不需要考虑，很少会出现一个单例类会主动要求被复制的情况，解决该问题的最好方法就是单例类不要实现Cloneable接口。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果一个类可以产生多个对象，对象的数量不受限制，则是非常容易实现的，直接使用new关键字就可以了，如果只要有一个对象，使用单例模式就可以了，但是如果要求一个类只能产生两三个对象呢？该怎么实现？我们还以皇帝为例来说明。</p>
<p>&ensp;&ensp;&ensp;&ensp;一般情况下，一个朝代的同一个时代只有一个皇帝，那有没有出现两个皇帝的情况呢？确实有，就出现在明朝，那三国期间的算不算？不算，各自称帝，各有各的地盘，国号不同。大家还记得《石灰吟》这首诗吗？作者是谁？于谦。他是被谁杀死的？明英宗朱祁镇。对，就是那个在土木堡之变中被瓦刺俘虏的皇帝，被俘虏后，他弟弟朱祁钰当上了皇帝，就是明景帝，估计刚当上皇帝乐疯了，忘记把他哥哥朱祁镇升级为太上皇，在那个时期就出现了两个皇帝，这期间的的大臣是非常郁闷的，为什么呀？因为可能出现今天参拜的皇帝和昨天的皇帝不相同，昨天给那个皇帝汇报，今天还要给这个皇帝汇报一遍，该情况的类图如图7-3所示。</p>
<p><img src="https://img3.doubanio.com/view/ark_works_pic/common-largeshow/public/87335.jpg" alt="7-3"></p>
<p>&ensp;&ensp;&ensp;&ensp;图7-3 多个皇帝类</p>
<p>&ensp;&ensp;&ensp;&ensp;这个类图看起来还算简单，但是实现就有点复杂了。Emperor类如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码清单7-5 固定数量的皇帝类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义最多能产生的实例数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxNumOfEmperor = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//定义一个列表，容纳所有的皇帝实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Emperor2&gt; emperorList = <span class="keyword">new</span> ArrayList&lt;Emperor2&gt;();</span><br><span class="line">    <span class="comment">//当前皇帝序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> countNumOfEmperor = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//产生所有的对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNumOfEmperor;i++)&#123;</span><br><span class="line">            emperorList.add(<span class="keyword">new</span> Emperor2(<span class="string">"皇帝"</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//皇帝名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        countNumOfEmperor = random.nextInt(maxNumOfEmperor);</span><br><span class="line">        <span class="keyword">return</span> emperorList.get(countNumOfEmperor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(nameList.get(countNumOfEmperor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在Emperor中使用了两个ArrayList分别存储实例和实例变量。当然，如果考虑到线程安全问题可以使用Vector来代替。臣子参拜皇帝的过程如代码清单7-6所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-6 臣子参拜皇帝的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义5个大臣</span></span><br><span class="line">        <span class="keyword">int</span> ministerNum=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ministerNum;i++) &#123;</span><br><span class="line">            Emperor2 emperor = Emperor2.getInstance();</span><br><span class="line">            System.out.print(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个大臣参拜的是："</span>+emperor);</span><br><span class="line">            emperor.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大臣参拜皇帝的结果如下所示。</span><br><span class="line">第<span class="number">1</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br><span class="line">第<span class="number">2</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br><span class="line">第<span class="number">3</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">6</span>bc168e5皇帝<span class="number">0</span></span><br><span class="line">第<span class="number">4</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">6</span>bc168e5皇帝<span class="number">0</span></span><br><span class="line">第<span class="number">5</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;看，果然每个大臣参拜的皇帝都可能不一样，大臣们就开始糊涂了，A大臣给皇1帝汇报了一件事情，皇2帝不知道，然后就开始怀疑大臣A是皇1帝的亲信，然后就想办法开始整……<br>这种需要产生固定数量对象的模式就叫做有上限的多例模式，它是单例模式的一种扩展，采用有上限的多例模式，我们可以在设计时决定在内存中有多少个实例，方便系统进行扩展，修正单例可能存在的性能问题，提供系统的响应速度。例如读取文件，我们可以在系统启动时完成初始化工作，在内存中启动固定数量的reader实例，然后在需要读取文件时就可以快速响应。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>&ensp;&ensp;&ensp;&ensp;单例模式是23个模式中比较简单的模式，应用也非常广泛，如在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理，等等。如果采用非单例模式（Prototype类型），则Bean初始化后的管理交由J2EE容器，Spring容器不再跟踪管理Bean的生命周期。</p>
<p>&ensp;&ensp;&ensp;&ensp;使用单例模式需要注意的一点就是JVM的垃圾回收机制，如果我们的一个单例对象在内存中长久不使用，JVM就认为这个对象是一个垃圾，在CPU资源空闲的情况下该对象会被清理掉，下次再调用时就需要重新产生一个对象。如果我们在应用中使用单例类作为有状态值（如计数器）的管理，则会出现恢复原状的情况，应用就会出现故障。如果确实需要采用单例模式来记录有状态的值，有两种办法可以解决该问题：</p>
<ul>
<li><p>由容器管理单例的生命周期</p>
<p>  Java EE容器或者框架级容器（如Spring）可以让对象长久驻留内存。当然，自行通过管理对象的生命期也是一个可行的办法，既然有那么多的工具提供给我们，为什么不用呢？</p>
</li>
<li><p>状态随时记录</p>
<p>  可以使用异步记录的方式，或者使用观察者模式，记录状态的变化，写入文件或写入数据库中，确保即使单例对象重新初始化也可以从资源环境获得销毁前的数据，避免应用数据丢失。</p>
</li>
</ul>
<h4 id="摘自：《设计模式之禅》-—-秦小波"><a href="#摘自：《设计模式之禅》-—-秦小波" class="headerlink" title="摘自：《设计模式之禅》 — 秦小波"></a>摘自：《设计模式之禅》 — 秦小波</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 方法引用</title>
    <url>/2019/12/25/JDK8_method/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<ul>
<li>方法引用：当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用</li>
<li>方法引用：在Lambda的基础上进一步的简化。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li>
<li>要求：实现接口的抽象方法体的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</li>
<li>使用操作符 :: 将类（或对象）与方法名分割开来</li>
<li>主要分为下面三种使用情况：<ol>
<li>对象 :: 实例方法名</li>
<li>类 :: 静态方法名</li>
<li>类 :: 实例方法名<a id="more"></a>
<h6 id="场景-模拟发送邮件"><a href="#场景-模拟发送邮件" class="headerlink" title="场景:模拟发送邮件"></a>场景:模拟发送邮件</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timingSendEamil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticEamil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" static 发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1、JDK8 之前</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> EmailService().timingSendEamil();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2、JDK8 后使用Lambda表达式优化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> EmailService().timingSendEamil();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3、因为方法引用是在Lambda的基础上进一步的简化,所以使用方法引用进一步优化上面的代码</span></span><br><span class="line"><span class="comment">         * 格式： 实例对象::实例方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EmailService emailService = <span class="keyword">new</span> EmailService();</span><br><span class="line">        <span class="keyword">new</span> Thread(emailService::timingSendEamil).start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4、拆分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runnable runnable = emailService::timingSendEamil;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 5、使用方法引用调用我们的静态方法</span></span><br><span class="line"><span class="comment">         * 格式: 类名::静态方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(EmailService::staticEamil).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6、使用方法引用调用构造方法</span></span><br><span class="line"><span class="comment">         * 格式： 类名::new</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(EmailService::<span class="keyword">new</span>).start();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 Lambda表达式</title>
    <url>/2019/12/25/JDK8_Lambda/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<ul>
<li>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</li>
<li>Lambda 允许把函数作为参数传递进方法中。</li>
<li>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</li>
<li>lambda表达式的重要特征:<ol>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。<a id="more"></a>
</li>
</ol>
</li>
</ul>
<hr>
<h6 id="JDK8-之前调用接口的方式是通过匿名内部类，调用接口中的方法。"><a href="#JDK8-之前调用接口的方式是通过匿名内部类，调用接口中的方法。" class="headerlink" title="JDK8 之前调用接口的方式是通过匿名内部类，调用接口中的方法。"></a>JDK8 之前调用接口的方式是通过匿名内部类，调用接口中的方法。</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface functionInterface = <span class="keyword">new</span> FunctionInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"get方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        functionInterface.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用Lambda表达式调用接口中的方法"><a href="#使用Lambda表达式调用接口中的方法" class="headerlink" title="使用Lambda表达式调用接口中的方法"></a>使用Lambda表达式调用接口中的方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface ft = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"JDK8 Lambda表达式调用：get方法"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        ft.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>() : 表示抽象方法所需的参数列表,(参数1，参数2)<br>-&gt; : 固定格式<br>{} ：表示抽象方法的方法体</p>
</blockquote>
<h6 id="有返回值的Lambda表达式调用方法"><a href="#有返回值的Lambda表达式调用方法" class="headerlink" title="有返回值的Lambda表达式调用方法"></a>有返回值的Lambda表达式调用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface2 functionInterface2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"有返回值的Lambda表达式调用方法"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(functionInterface2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 优化：有返回值的Lambda表达式调用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FunctionInterface2 functionInterface3 = () -&gt; <span class="string">"优化：有返回值的Lambda表达式调用方法"</span>;</span><br><span class="line">        System.out.println(functionInterface3.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="有参数，有返回值的Lambda表达式调用方法"><a href="#有参数，有返回值的Lambda表达式调用方法" class="headerlink" title="有参数，有返回值的Lambda表达式调用方法"></a>有参数，有返回值的Lambda表达式调用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface3</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface3 ft3 = (String s)-&gt; s;</span><br><span class="line">        System.out.println(ft3.get(<span class="string">"有参数，有返回值的Lambda表达式调用方法"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 函数接口</title>
    <url>/2019/12/25/JDK8_FunctionInterface/</url>
    <content><![CDATA[<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><blockquote>
<p>定义:接口中只有唯一的一个抽象方法，该接口就称之为函数接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>@FunctionInterface: <br/><br> JDK 8推出了一个重要的注解@FunctionInterface<br> @FunctionInterface:作用主要用来强制约定一个接口只允许一个抽象方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、使用@FunctionInterface注解后，该接口只能有一个抽象方法，</span></span><br><span class="line">    <span class="comment">//   get2() 方法放开会报错</span></span><br><span class="line">    <span class="comment">//void get2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数接口中支持 default 和 static 关键字修饰我们的方法，允许存在Object类中equals方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、使用@FunctionInterface注解后，该接口只能有一个抽象方法，</span></span><br><span class="line">    <span class="comment">//void get2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、函数接口中支持 default 和 static 关键字修饰我们的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是default修饰的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是static修饰的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、重点：允许存在Object类中equals方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK中存在的函数接口：<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;Runnable:用于创建线程 <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;Comparator:用于比较对象</p>
</blockquote>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 default关键字</title>
    <url>/2019/12/23/JDK8_default/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<br/></h3><ul>
<li>Jdk1.8之前的接口中只声明方法，方法具体实现应在子类中进行。<br/></li>
<li>Jdk1.8打破了这样的用法：接口中可以实现具体的方法体，只需要加上关键字static或者default修饰即可。<br/><a id="more"></a></li>
</ul>
<ol>
<li><p>default关键字</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    //自定义方法</span><br><span class="line">    void getUsername();</span><br><span class="line">    //默认方法</span><br><span class="line">    default void <span class="function"><span class="title">defaultUsername</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //默认方法,子类重写</span><br><span class="line">    default void <span class="function"><span class="title">overrideDefaultUsername</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">overrideDefaultUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        userService.getUsername();</span><br><span class="line">        userService.defaultUsername();</span><br><span class="line">        userService.overrideDefaultUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"结果打印数据："</span></span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername</span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername</span><br></pre></td></tr></table></figure>
</li>
<li><p>static关键字</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">void getUsername();</span><br><span class="line"></span><br><span class="line">default void <span class="function"><span class="title">defaultUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void <span class="function"><span class="title">overrideDefaultUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="function"><span class="title">staticUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;staticUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">overrideDefaultUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">在子类中发现不能重写被static关键字修饰的方法。</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        userService.getUsername();</span><br><span class="line">        userService.defaultUsername();</span><br><span class="line">        userService.overrideDefaultUsername();</span><br><span class="line">        UserService.staticUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"结果打印数据"</span></span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername</span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;staticUsername</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结<br>&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. detault关键字修饰的方法称为默认方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 子类可以选择性的是否重写该方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 接口中的default方法通过实例对象来调用<br>&nbsp;&nbsp;static:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. static关键字修饰的方法称为静态方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 子类不能重写该方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 接口中的静态方法通过接口名.方法名()的方式来</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
