<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git pull 报错：The following untracked working tree files would be overwritten by merge</title>
    <url>/2020/02/07/GitBug-GitPullException/</url>
    <content><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>使用 git pull 命令更新报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Updating d652d1c..fa05549 error: The following untracked working tree files would be overwritten by merge:.idea&#x2F;encodings.xml</span><br><span class="line"></span><br><span class="line">Please move or remove them before you can merge. Aborting</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用  git clean -d -fx 命令即可。</p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Git BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-compose 安装与基本使用(四)</title>
    <url>/2020/01/28/Docker4-Docker-Hub-Manager/</url>
    <content><![CDATA[<h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker-Compose"></a>安装 Docker-Compose</h3><p>Compose有多种安装方式,例如通过 shell, pip以及将 Compose作为容器安装等。本次安装以Shell 为主。</p>
<ol>
<li>通过以下命令自动下载并安装适应系统版本的 Compose:<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.10.0/docker-compose-$(uname -s)-$(uname -m)"</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li>
<li>为安装脚本添加执行权限<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">chmod +x/usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<a id="more"></a>
这样, Compose就安装完成了。<br>可使用以下命令测试安装结果:<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
可输出类似于如下的内容:4 586bhjnkmv<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker-compose version <span class="number">1.10</span>.<span class="number">0</span>, build <span class="number">4</span>bd6f1a</span><br></pre></td></tr></table></figure>
说明 Compose已成功安装。</li>
</ol>
<h3 id="安装-Compose命令补全工具"><a href="#安装-Compose命令补全工具" class="headerlink" title="安装 Compose命令补全工具"></a>安装 Compose命令补全工具</h3><p>现在已成功安装 Compose,然而当输 Docker Compose并按下Tab键时, Compose并没有补全命令。要想使用 Compose的命令补全,需要安装命令补全工具。<br>命令补全工具在Bash和zsh下的安装方式不同,本次以Bash安装为主。<br>执行以下命令,即可安装命令补全工具:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">curl -l https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>
<p>这样,在重新登录后,输入 docker-compose并按下Tab键,compose就可自动补全命令了。</p>
<h3 id="Docker-Compose-快速入门"><a href="#Docker-Compose-快速入门" class="headerlink" title="Docker Compose 快速入门"></a>Docker Compose 快速入门</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>使用 Docker Compose 大致有 3 个步骤：</p>
<ul>
<li>使用 Dockerfile (或其他方式)定义应用程序环境，以便在任何地方重现该环境。</li>
<li>在 docker-compose.yml 文件中定义组成应用程序的服务，以便各个服务在一个隔离的环境中一起运行。</li>
<li>运行 docker-compose up 命令，启动并运行整个应用程序。</li>
</ul>
<h4 id="人门示例"><a href="#人门示例" class="headerlink" title="人门示例"></a>人门示例</h4><p>下面以 wzq-swagger-mng 为例讲解 compose 的基本步骤。</p>
<ol>
<li>使用 mvn clean package 命令打包项目，获得 wzq-swagger-mng.jar。</li>
<li>在 wzq-swagger-mng.jar 所在路径(默认是项目的 target 目录)创建 Dockerfile 文件，并在其中添加如下内容。<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> wzq-swagger-mng.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">'touch /app.jar'</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10086</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-Djava.security.edg=file:/dev/.urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>在 wzq-swagger-mng.jar 所在路径创建文件 docker-compose.yml,在其中添加如下内容。<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'2'</span><span class="comment"># 表示该docker-compose.yml文件使用的是version 2 file</span></span><br><span class="line">services:</span><br><span class="line">  wzq-swagger-mng:<span class="comment"># 指定服务名称</span></span><br><span class="line">    build:<span class="comment">#指定Dockerfile所在文件夹的路径</span></span><br><span class="line">      context: ./</span><br><span class="line">      dockerfile: ./Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">"10086:10086"</span><span class="comment"># 指定端口映射，类似 docker run 的 -p 选项,注意使用字符串形式。</span></span><br></pre></td></tr></table></figure></li>
<li>在 docker-compose.yml 所在路径执行以下命令:<br>docker-compose up<br>Compose就会自动构建镜像并使用镜像启动容器。也可使用 docker-compose up -d后台启动并运行这些容器。</li>
<li>测试访问<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-compose.jpg" alt="docker-compose测试页面"></li>
</ol>
<h4 id="工程、服务、容器"><a href="#工程、服务、容器" class="headerlink" title="工程、服务、容器"></a>工程、服务、容器</h4><p>Docker Compose将所管理的容器分为三层,分别是工程(project),服务(service)以及容器(container)。Docker Compose运行目录下的所有文件( docker-compose.yml、extends文件或环境变量文件等)组成一个工程(默认为 docker-compose.yml所在目录的目录名称)。一个工程可包含多个服务,每个服务中定义了容器运行的镜像、参数和依赖,一个服务可包括多个容器实例。<br>对应上面案例中工程名称是 docker-compose.yml 所在的目录名。该工程包含了1个服务,服务名称是 wzq-swagger-mng。执行 docker-compose up -d 时,启动了 wzq-swagger-mng 服务的1个容器实例。</p>
<h3 id="docker-compose-yml-常用命令"><a href="#docker-compose-yml-常用命令" class="headerlink" title="docker-compose.yml 常用命令"></a>docker-compose.yml 常用命令</h3><p>docker-compose.yml是 Compose的默认模板文件。该文件有多种写法,例如 Version 1 file format、 Version2 file format、Version2. 1 file format、 Version3 file format等。其中, Version 1 file format将逐步被被弃用, Version2x及 Version3x基本兼容,是未来的趋势。本次只讨论 Version2 file format下的常用命令。</p>
<ol>
<li><p>build<br>配置构建时的选项, Compose会利用它自动构建镜像。buld的值可以是一个路径<br>例如</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">build:./Dockerfile</span><br></pre></td></tr></table></figure>
<p>也可以是一个对象,用于指定 Dockerfile和参数,<br>例如</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: ./</span><br><span class="line">  dockerfile: ./Dockerfile</span><br><span class="line">agrs:</span><br><span class="line">  jacob: <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>command<br>覆盖容器启动后默认执行的命令,示例</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">command: bundle exec thin -p <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<p>也可以是一个list,类似于 Dockerfile中的CMD指令,格式如下:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">command: [bundle, exec, thin,-p, <span class="number">3000</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>dns<br>配置dns服务器。可以是一个值,也可以是一个列表。示例:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">dns: <span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">dns:</span><br><span class="line">  - <span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">  - <span class="number">9.9</span>.<span class="number">9.9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dns_search<br>配置DNS的搜索域,可以是一个值,也可以是一个列表。示例</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">dns_search:example.com</span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>environment<br>环境变量设置,可使用数组或字典两种方式。示例:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">environment</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: true</span><br><span class="line">  SESSION SECRET</span><br><span class="line"></span><br><span class="line">environment</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=true</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>
</li>
<li><p>env_file<br>从文件中获取环境变量,可指定一个文件路径或路径列表。如果通过 docker-compose FILe指定了 Compose 文件,那么 eny_file中的路径是 Compose 文件所在目录的相对路径。使用 environment 指定的环境变量会覆盖 eny_file指定的环境变量。示例</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">eny_file: .<span class="keyword">env</span></span><br><span class="line">eny_file</span><br><span class="line">  - /common.<span class="keyword">env</span></span><br><span class="line">  - /apps/web.<span class="keyword">env</span></span><br><span class="line">  - /opt/secrets. <span class="keyword">env</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>expose<br>暴露端口,只将端口暴露给连接的服务,而不暴露给宿主机。示例:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">expose</span>:</span><br><span class="line">  - <span class="string">"3000"</span></span><br><span class="line">  - <span class="string">"8090"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>external_links<br>连接到 docker-compose.yml外部的容器,甚至并非 Compose 管理的容器,特别是提供共享或公共服务的容器。格式跟 links类似,例如:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">external_links:</span><br><span class="line">  - redis_1</span><br><span class="line">  - project_db_1: mysql</span><br><span class="line">  - project_db_1: postgresql</span><br></pre></td></tr></table></figure>
</li>
<li><p>image<br>指定镜像名称或镜像Id,如果本地不存在该镜像, Compose会尝试下载该镜像。<br>示例</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">image: Java</span><br></pre></td></tr></table></figure>
</li>
<li><p>links<br>连接到其他服务的容器。可以指定服务名称和服务别名( SERVICE: ALIAS),也可只指定服务名称。例如:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">web:</span><br><span class="line">  links:</span><br><span class="line">    - db</span><br><span class="line">    - db:database</span><br><span class="line">    - redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>networks<br><a href="#">后续详解</a></p>
</li>
<li><p>network_mode<br>设置网络模式。示例</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">network_mode: <span class="string">"bridge"</span></span><br><span class="line">network_mode: <span class="string">"host"</span></span><br><span class="line">network_mode: <span class="string">"none"</span></span><br><span class="line">network_mode: <span class="string">"service:[service name]"</span></span><br><span class="line">network_mode: <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ports<br>暴露端口信息,可使用H0ST:CONTAINER的格式,也可只指定容器端口(此时宿主机将会随机选择端口),类似于 docker run-p。<br>需要注意的是,当使用H0ST:CONTAINER格式映射端口时,容器端口小于60将会得到错误的接口,因为yaml会把xx:yy的数字解析为60进制。因此,建议使用字符串的形式。示例:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">ports</span><br><span class="line">  - <span class="string">"3000"</span></span><br><span class="line">  - <span class="string">"3000-3905"</span></span><br><span class="line">  - <span class="string">"8000:8000"</span></span><br><span class="line">  - <span class="string">"9099-9091:8080-8081"</span></span><br><span class="line">  - <span class="string">"49100:22"</span></span><br><span class="line">  - <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line">  - <span class="string">"127,0.0.1:5000-5010:5000-5010"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>volumes<br>卷挂载路径设置。可以设置宿主机路径(HOST:CONTAINER),也可指定访问模式(HOST:C0ONTAINER:ro)。示例:</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">volumes</span><br><span class="line">  <span class="comment"># Just specify a path and let the Engine create a volume</span></span><br><span class="line">  - /var/lib/mysql</span><br><span class="line">  <span class="comment"># Specify an absolute path mapping</span></span><br><span class="line">  - /opt/data:/var/lib/mysql</span><br><span class="line">  <span class="comment"># Path on the host relative to the Compose file</span></span><br><span class="line">  - ./cache:/tmp/cache</span><br><span class="line">  <span class="comment"># User-relative path</span></span><br><span class="line">  - ~/configs:/etc/configs/:ro</span><br><span class="line">  <span class="comment">#f Named volume</span></span><br><span class="line">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>volumes_from<br>从另一个服务或容器挂载卷。可指定只读(ro)或读写(rw),默认是读写(rw)。<br>示例</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">volumes <span class="keyword">from</span></span><br><span class="line">  - service_name</span><br><span class="line">  - service_name:ro</span><br><span class="line">  - container:container_name</span><br><span class="line">  - container:container_name:rw</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>docker-compose.yml还有很多其他命令,比如 depends_on、pid、 devices等。<br>本次仅挑选常用的命令进行讲解,其他命令不再赘述。感兴趣的读者们可参考官方文档:<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 使用Dockerfile构建Docker(三)</title>
    <url>/2020/01/25/Docker3-Deockerfile/</url>
    <content><![CDATA[<h3 id="Dockerfile-简单使用"><a href="#Dockerfile-简单使用" class="headerlink" title="Dockerfile 简单使用"></a>Dockerfile 简单使用</h3><p>先来编写一个最简单的 Dockerfile。</p>
<ol>
<li>例如：<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;使用Dockerfile构建镜像&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>
该 Dockerfile 非常简单，其中的 FORM 、 RUN 都是 Dockerfile 的指令。<br>FROM 指令用于指定基础镜像 RUN 指令用于执行命令</li>
<li>在 Dockerfile 所在路径执行一下命令构建镜像：<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:my .</span><br></pre></td></tr></table></figure>
其中，命令最后的点（.）用于路径参数传递，表示当前路径。<a id="more"></a></li>
<li>执行以下命令,即可使用该镜像启动一个 Docker容器。<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 92:80 nginx:my</span></span><br></pre></td></tr></table></figure></li>
<li>访问查看到效果(页面是因为编码问题)。<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/nginx.jpg" alt=""><br>从本例不难看出 Dockerfile的强大。仅仅编写了两行代码,就修改了原始镜像的行为。不仅如此,通过 Dockerfile,还可直观地看到修改镜像的具体过程。<blockquote>
<p>除了使用Dockerfile构建镜像,也可手工制作 Docker镜像,但这种方式烦琐效率低,一般不适合生产。</p>
</blockquote>
</li>
</ol>
<h3 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h3><p>在前面的例子中,提到了FORM、RUN指令。事实上, Dockerfile有十多个指令,指令的一般格式为:指令名称参数。</p>
<ol>
<li><p>ADD复制文件<br>ADD 指令用于复制文件,格式为:<br>ADD &lt;src&gt;… &lt;dest&gt;<br>ADD [“&lt;srv&gt;”… “&lt;dest&gt;”]<br>从src目录复制文件到容器的dest。其中src可以是 Dockerfile所在目录的相对路径,也可以是一个URL,还可以是一个压缩包。</p>
<blockquote>
<p>注意:<br>1、src必须在构建的上下文内,不能使用例如:ADD ../somethine/something这样的命令,因为 docker bui1d命令首先会将上下文路径和其子目录发送到 docker daemon。<br>2、如果src是一个URL,同时dest不以斜杠结尾,dest将会被视为文件,src对应内容文件将会被下载到 dest。<br>3、如果src是一个URL,同时dest以斜杠结尾,dest将被视为目录,src对应内容将会被下载到dest目录。<br>4、如果 src 是一个目录，那么整个目录下的内容将会被复制，包括文件系统元数据。<br>5、如果文件是可识别的压缩包格式，则 doclcer 会自动解压。<br>示例：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> wzq-swagger-mng.jar app.jar</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>ARG 设置构建参数<br>ARG 指令用于设置构建参数，类似于 ENV。和 ARG 不同的是， ARG 设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。<br>格式为： ARG &lt;name&gt; [&lt;default value&gt;]。<br>示例： ARG user=Jacob</p>
</li>
<li><p>CMD 容器启动命令<br>CMD 指令用于为执行容器提供默认值。每个 Dockerfile 只有一个 CMD 命令，如果指定了多个 CMD 命令，那么只有最后一条会被执行，如果启动容器时指定了运行的命令，则会覆盖掉 CMD 指定的命令。<br>支持 3 种格式：<br>CMD [&quot;executable&quot;,&quot;paraml&quot;,&quot;param2&quot;] (推荐使用)<br>CMD [&quot;param1&quot;,&quot;param2&quot;](为 ENT 盯 PoINT 指令提供预设参数)<br>CMD command param1 param2 (在 shell 中执行)<br>示例： CMD echo &quot; This 15 a test .&quot; | wc -</p>
</li>
<li><p>COPY 复制文件<br>复制文件，格式为：<br>COPY &lt;src&gt;… &lt;dest&gt;<br>COPY [&quot;&lt;src&gt;&quot;,… &quot;&lt;dest&gt;&quot;]<br>复制本地的 src 到容器的 dest 。COPY 指令和 ADD 指尘类似， COPY 不支持 URL 和 压缩包。</p>
</li>
<li><p>ENTRYPOINT 人口点<br>格式为：<br>ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;;&quot;param2&quot;]<br>ENTRYPOINT command param1 param2<br>ENTRYPOINT 和 CMD指令目的是一样的，都是指定 Docker 容器启动时执行的命令，可多次设置，但只有最后一个有效。</p>
</li>
<li><p>ENV 设置环境变量<br>ENV 指令用于设置环境变量，格式为：<br>ENV &lt;key&gt; &lt;value&gt;<br>ENV &lt;key&gt;=&lt;value&gt;<br>示例： ENV JAVA_HOME /path/to/java</p>
</li>
<li><p>EXPOSE声明暴露的端口<br>EXPOSE 指令用于声明在运行时容器提供服务的端口，格式为： EXPOSE &lt;port&gt; [&lt;port&gt;…]。<br>需要注意的是，这只是一个声明，运行时并不会因为该声明就打开相应端口。该指令的作用主要是帮助镜像使用者理解该镜像服务的守护端口；其次是当运行时使用随机映射时，会自动映射 EXP0SE 的端口。<br>示例：</p>
</li>
</ol>
<ul>
<li>声明暴露一个端口示例 EXPOSE port1</li>
<li>相应的运行容器使用的命令 docker run -p port1 image</li>
<li>也可使用一 P 选项启动 docker run -P image</li>
<li>声明暴露多个端口示例 EXPOSE port1 port2 port3</li>
<li>相应的运行容器使用的命令 docker run -p port1 -p port2 -p port3 image</li>
<li>也可指定需要映射到宿主机器上的端口号 docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image </li>
</ul>
<ol start="8">
<li>FROM 指定基础镜像<br>使用 FORM 指令指定基础镜像，FORM 指令有点像 Java 里面的 extends 关键字。需要注意的是，FROM 指令必须指定且需要写在其他指令之前。 FORM 指令后的所有指令都依赖于该指令所指定的镜像。<br>支持 3 种格式：<br>FROM &lt;image&gt;<br>FROM &lt;image&gt;:&lt;tag&gt;<br>FROM &lt;image&gt;@&lt;digest&gt;</li>
<li>LABEL 为镜像添加元数据<br>LABEL 指令用于为镜像添加元数据。<br>格式为：LABLE &lt;key&gt;=&lt;volue&gt; &lt;key&gt;=&lt;volue&gt; &lt;key&gt;=&lt;volue&gt; …。<br>使用“ “ ”和“ \ ”转换命令行。<br>示例：<br>LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;<br>LABEL com.example.label-with-value=&quot;foo&quot;<br>LABEL version=&quot;1.0”<br>LABLE description=&quot;This text illustrates that label-values can span multlple lines.&quot;</li>
<li>MAINTAINER 指定维护者的信息<br>MAINTAINER 指令用于指定维护者的信息，用于为 DOCkerfile 署名。格式为： MAINTAINR &lt;name&gt;。<br>示例：<br>MAINTAINER Jacob&lt;<a href="mailto:596766829@qq.com">596766829@qq.com</a>&gt;</li>
<li>RUN 执行命令<br>该指令支持两种格式：<br>RUN &lt;Command&gt;<br>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]<br>UuN &lt;command&gt;在 shell 终端中运行，在 Linux 中默认是/bin/Sh -C ，在 Windows 中是 cmd /s /c，使用这种格式，就像直接在命令行中输人命令一样。 RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，这种方式类似于函数调用。指定其他终端可以通过该方式操作，例如： RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;] ，该方式必须使用双引号”而不能使用单引号’，因为该方式会被转换成一个 JsON 数组。</li>
<li>USER 设置用户<br>该指令用于设置启动镜像时的用户或者 UID ，写在该指令后的 RUN 、 CMD 以及 ENTRYPOINT 指令都将使用该用户执行命令。<br>格式为：USER 用户名。<br>示例： USER Jacob</li>
<li>VOLUME 指定挂载点<br>该指令使容器中的一个目录具有持久化存储的功能，该目录可被容器本身使用，也可共享给其他容器。当容器中的应用有持久化数据的需求时可以在 Dockerfile 中使用该指令。格式为：VOLUME [&quot;data&quot;。<br>示例： VOLUME /data </li>
<li>WORKDIR 指定工作目录<br>格式为： WORKOIR /path/to/workdir。<br>切换目录指令，类似于 cd 命令，写在该指令后的 RUN , CMD 以及 ENTRYPOINT 指令都将该目录作为当前目录，并执行相应的命令。</li>
<li>其他<br>Dockerfile 还有一些其他的指令，例如 STOPSINGAL、HEALTHcHECK、SHELL 等。有兴趣的可前往 <a href="https://docs.docker.com/engine/reference/builder/进行扩展阅读。" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/进行扩展阅读。</a></li>
</ol>
<h3 id="使用-Dockerfile-构建-Docker-镜像"><a href="#使用-Dockerfile-构建-Docker-镜像" class="headerlink" title="使用 Dockerfile 构建 Docker 镜像"></a>使用 Dockerfile 构建 Docker 镜像</h3><ol>
<li>准备工作<br>准备一个Jar包,本次使用的Jar包是springboot整合swagger。</li>
<li>使用Dockerfile 构建 Docker 镜像<br>创建 Dockerfile 文件,并添加一下内容<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="comment">#指定镜像</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="comment">#将本地文件夹挂载到当前容器</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="comment">#复制文件到容器</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> wzq-swagger-mng.jar app.jar</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">'touch /app.jar'</span></span></span><br><span class="line"><span class="comment">#声明需要暴露的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10086</span></span><br><span class="line"><span class="comment">#配置容器启动后需要执行的命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-Djava.security.edg=file:/dev/.urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure></li>
<li>使用 docker build 命令构建镜像<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker build -t itouch/wzq-swagger-mng .</span><br></pre></td></tr></table></figure>
<img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-build.jpg" alt=""></li>
<li>启动镜像<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -p 10086:10086 itouch/wzq-swagger-mng</span></span><br></pre></td></tr></table></figure></li>
<li>测试<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-swagger.jpg" alt=""><br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-test.jpg" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 常用命令(二)</title>
    <url>/2020/01/24/Docker2-ChangYongMingLing/</url>
    <content><![CDATA[<h3 id="Docker-镜像常用命令"><a href="#Docker-镜像常用命令" class="headerlink" title="Docker 镜像常用命令"></a>Docker 镜像常用命令</h3><ul>
<li>搜索镜像<br>可使用 docker search 命令搜索存放在 Docker Hub 中的镜像。例如： docker search java 执行该命令后， Docker 就会在 Docker Hub 中搜索含有 java 这个关键词的镜像仓库。执行该命令后，可看到类似于如下的表格：<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-java.jpg" alt=""><br>该表格包含五列，含义如下。</li>
</ul>
<ul>
<li>NAME ：镜像仓库名称。</li>
<li>DESCRIPTION ：镜像仓库描述。</li>
<li>STARS ：镜像仓库收藏数，表示该镜像仓库的受欢迎程度，类似于 GitHub 的 Stars 。</li>
<li>OFFICIAL ：表示是否为官方仓库，该列标记为 [OK] 的镜像均由各软件的官方项目组创建和维护。由结果可知，前8个镜像仓库是官方仓库，而其他的仓库都不是镜像仓库。</li>
<li>AuTOMATED ：表示是否是自动构建的镜像仓库。<a id="more"></a></li>
</ul>
<ul>
<li>下载镜像<br>使用命令 docker pull 命令即可从 Docker Registry 上下载镜像，例如： docker putl j ava 执行该命令后， Docker 会从 Docker Hub 中的 Java 仓库下载最新版本的 Jaya 镜像。若镜像下载缓慢，可配置镜像加速器，<a href="https://jacob.org.cn/2020/01/23/Docker1-JianDanRuMen/">Docker 简单入门(一)</a>。该命令还可指定想要下载的镜像标签以及 Docker Registry 地址，例如： docker pull reg.itmuch.com/java:7 这样就可以从指定的 Docker Registry 中下载标签为 7 的 Java 镜像。</li>
<li>列出镜像<br>使用 docker images 命令即可列出已下载的镜像。执行该命令后，将会看到类似于如下的表格：<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-images.jpg" alt=""><br>该表格包含了 5 列，含义如下。</li>
</ul>
<ul>
<li>REPOSITORY ：镜像所属仓库名称。</li>
<li>TAG ：镜像标签。默认是 latest ，表示最新。</li>
<li>IMAGE ID ：镜像 ID ，表示镜像唯一标识。</li>
<li>CREATED ：镜像创建时间。</li>
<li>SIZE ：镜像大小</li>
</ul>
<ul>
<li><p>删除本地镜像<br>使用 docker rmi 命令即可删除指定镜像。</p>
<p>  例1 ：删除指定名称的镜像。<br>  doCker rmi hello-world 表示删除 hello-world 这个镜像。<br>  例 2 ：删除所有镜像。<br>  docker rmi -f $(docker images)<br>  -f 参数表示强制删除。</p>
</li>
</ul>
<h3 id="Docker-容器的常用命令"><a href="#Docker-容器的常用命令" class="headerlink" title="Docker 容器的常用命令"></a>Docker 容器的常用命令</h3><ol>
<li>新建并启动容器<br>使用一下docker run 命令即可新建并启动一个容器。<br>该命令是最常用的命令，它有很多选项下面将列举一些常用的选项：<br> -d选项:表示后台运行<br> -P选项:随机端口映射<br> -p选项:指定端口映射,有以下四种格式。<pre><code>ip: hostPort: containerPort
p: containerport
hostPort: containerPort
container port</code></pre> network选项:指定网络模式,该选项有以下可选参数:<br> –network=bridge:默认选项,表示连接到默认的网桥。<br> –network=host:容器使用宿主机的网络。<br> –network=container:NAME_or_ID:告诉 Docker让新建的容器使用已有容器的网络配置<br> –network=none:不配置该容器的网络,用户可自定义网络配置。<br> 示例1 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run java &#x2F;bin&#x2F;echo &#39;Hello World&#39;</span><br></pre></td></tr></table></figure>
 这样终端会打印 Hello world的字样,跟在本地直接执行/bin/echo” Hello World”一样。<br> 示例2: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d-p 91: 80 nginx</span><br></pre></td></tr></table></figure>
 这样就能启动一个Ngnx容器。在本例中,为 docker run添加了两个参数,含义如下:<br> -d # 后台运行<br> -p宿主机端口:容器端口 # 开放容器端口到宿主机端口<br> 访问htt: Docker宿主机IP:91/<blockquote>
<p>需要注意的是,使用 docker run命令创建容器时,会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像, Docker就会自动从 Docker Hub下载镜像并启动一个 Docker容器。</p>
</blockquote>
</li>
<li>列出容器<br> 使用 docker ps命令即可列出运行中的容器执行该命令后,可看到类似于如下的表格。<br> <img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-ps.jpg" alt=""><br> 如需列出所有容器(包括已停止的容器),可使用-a参数。<br> 该表格包含了7列,含义如下。<br> CONTAINER ID:表示容器I。<br> MAGE:表示镜像名称。<br> COMMAND:表示启动容器时运行的命令。<br> CREATED:表示容器的创建时间。<br> STATUS:表示容器运行的状态。U表示运行中, Exited表示已停止<br> PORTS:表示容器对外的端口号。<br> NAMES:表示容器名称。该名称默认由 Docker自动生成,也可使用 docker run 命令的-name选项自行指定。</li>
<li>停止容器<br>使用 docker stop命令,即可停止容器。例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 784fd3b294d7</span><br></pre></td></tr></table></figure>
中784635294d7是容器ID,当然也可使用 ocker stop容器名称来停止指定容器。</li>
<li>强制停容器<br>可使用 docker kill命令发送 SIGKILL信号来强制停止容器。例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker kill 784fd3b294d7</span><br></pre></td></tr></table></figure></li>
<li>启动已停止的容器<br>使用 docker run命令,即可新建并启动一个容器。对于已停止的容器,可使用 docker start命令来启动。例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 784fd3b294d7</span><br></pre></td></tr></table></figure></li>
<li>重启容器<br>可使用 docker restart命令来重启容器。该命令实际上是先执行了 locker stop命令,然后执行了 docker start 命令。</li>
<li>进入容器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container exec -i -t 容器ID &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>
<li>删除容器<br>使用 docker rm 命令即可删除看定溶器。<br>例1:删除指定容器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 784fd3b294d7</span><br></pre></td></tr></table></figure>
该命令尽能删除已停止的容器,如需删除正在运行的容器,可使用 -f 参数。<br>例2:删除所有的容器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 简单入门(一)</title>
    <url>/2020/01/23/Docker1-JianDanRuMen/</url>
    <content><![CDATA[<h3 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h3><p>Docker是一个开源的容器引擎，它有助于更快地交付应。Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序-样进行管理。使用Docker，可更快地打包、测试以及部署应用程序,并可以缩短从编写到部署运行代码的周期。</p>
<blockquote>
<p>Docker的官方网站: <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>Docker的GitHub: <a href="https://github.com/docker/docker/" target="_blank" rel="noopener">https://github.com/docker/docker/</a></p>
</blockquote>
<a id="more"></a>
<h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>Docker 架构图如下:<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker.jpg" alt=""><br>图中包含的组件：</p>
<ul>
<li><p>Docker daemon ( Docker守护进程)<br>  Docker daemon是一个运行在宿主机( DOCKER HOST )的后台进程。可通过Docker客户端与之通信。</p>
</li>
<li><p>Client ( Docker 客户端）<br>  DoCker 客户端是 DOCke ：的用户界面，它可以接受用户命令和配置标识，并与 DOCker daemon 通信。图中， docke : build 等都是 Docke ：的相关命令。</p>
</li>
<li><p>Images ( Docker 镜像）<br>  DOCker 镜像是一个只读模板，它包含创建 DoCker 容器的说明。它和系统安装光盘有点像 ― 使用系统安装光盘可以安装系统，同理，使用 D 。 cke ：镜像可以运行 Docker 镜像中的程序。</p>
</li>
<li><p>Container （容器）<br>  容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。可通过 Docker API 或者 Cll 命令来启停、移动、删除容器。</p>
</li>
<li><p>Registry<br>  Docker Registry 是一个集中存储与分发镜像的服务。构建完 Docker 镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，就需要手动复制。此时可借助 Docker Registry 来避免镜像的手动复制。一个 Docker Registry 可包含多个 Doclcer 仓库，每个仓库可包含多个镜像标签，每个标签对应一个 Docker 镜像。这跟 Maven 的仓库有点类似，如果把 Docker Registry 比作 Maven 仓库的话，那么 Docker 仓库就可理解为某 jar 包的路径，而镜像标签则可理解为 jar 包的版本号。</p>
<p>  Docker Registry 可分为公有 Docker Registry 和私有 Docker Registry 。最常用的 Docker Registry 莫过于官方的 Docker Hub ，这也是默认的 Doclcer Registry 。 Doclcer 枷 b 上存放着大量优秀的镜像，可使用 DoCker 命令下载并使用。</p>
</li>
</ul>
<h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><p>DoCker 官方建议将 Docker 运行在 Linux 操作系统上。当然Docke也可运行在其他的平台，例如windows、MacOS 等。<br>本次将演示如何在 CentOS 上安装 Docker ，其他操作系统上的安装可参考官方文档： <a href="https://docs.docker.com/engine/installation/。" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/。</a></p>
<h4 id="Docker-系统要求"><a href="#Docker-系统要求" class="headerlink" title="Docker 系统要求"></a>Docker 系统要求</h4><p>Docker 运行在 CentOS 7 . X 之上。<br>Docke ：需要安装在 64 位平台.</p>
<h4 id="卸载旧版Docker"><a href="#卸载旧版Docker" class="headerlink" title="卸载旧版Docker"></a>卸载旧版Docker</h4><p>sudo yum -y remove docker-ce 执行该命令只会移除旧版本的 docker-ce , /var/lib/docker 目录中的内容不会被删除，因此，旧版本 Docker-ce所创建的镜像、容器、卷等都会保留下来。</p>
<h4 id="设置-Yum-源"><a href="#设置-Yum-源" class="headerlink" title="设置 Yum 源"></a>设置 Yum 源</h4><p>Docker 有很多中安装方式：例如Yum安装、RPM安装、Shell安装。本次以Yum安装为例。</p>
<ol>
<li>安装 yum-utils，这样就能使用 yum-config-manager 工具设置 Yum 源。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure></li>
<li>执行以下命令，添加 Docker 的 Yum 源。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>[可选]启用测试仓库<br> 测试仓库包含在 docker.repo 文件中，但默认情况下是禁用的。如需启用测试仓库，可使用以下命令： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-conflg-manager -enable docker-testing</span><br></pre></td></tr></table></figure>
 想要禁用测-试仓库，可执行以下命令： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager -disable docker-testing</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><ol>
<li><p>更新 Yum 包的索引。 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure></li>
<li><p>安装最新版本的 Docker。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y Install docker-ce</span><br></pre></td></tr></table></figure>
<p> 这样，经过-段时间的等待后， Docker 就安装完成了。</p>
</li>
<li><p>在生产系统中，可能需要安装指定版本的 Docker ，而并不总是安装最新版本。执行以下命令，即可列出可用的 Docker 版本。 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list docker-ce.x86_64_showduplicates |sort -r</span><br></pre></td></tr></table></figure>
<p> 其中， sort -r 命令表示对结果由高到低排序。列出 Docker 版本，可使用以下命令安装指定版本的 Docker。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum - y install docker-ce-＜VERSION_STRIN6&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure></li>
<li><p>启动 DokCero </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>执行以下命令，验证安装是否正确。 </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hell0-World</span><br></pre></td></tr></table></figure>
<p> 如看到类似于如下的结果，则说明安装正确。<br> Unable to find image ‘hello-world:latest’ locally<br> …<br> Hello from docker!<br> This message shows that your installation appears to be working correctly.<br> …</p>
</li>
<li><p>查看 Docker 版本。<br>docker version 可看到类似于如下的结果：<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/docker-version.png" alt=""></p>
</li>
</ol>
<h4 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h4><ol>
<li>卸载 Doclcer 软件包。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum -y remove docker-ce</span><br></pre></td></tr></table></figure></li>
<li>如需删除镜像、容器、卷以及自定义的配置文件，可执行以下命令: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;var&#x2F;docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="配置阿里镜像加速器"><a href="#配置阿里镜像加速器" class="headerlink" title="配置阿里镜像加速器"></a>配置阿里镜像加速器</h3><p>国内访问 Docker Hub 的速度很不稳定，有时甚至出现连接不上的情况。本节来为 Docker 配置镜像加速器，从而解决这个问题。目前国内很多云服务商都提供了镜像加速的服务。常用的镜像加速器有：阿里云加速器、 DaoCloud 加速器等。各厂商镜像加速器的使用方式大致类似，本节以阿里云加速器为例进行讲解。</p>
<ol>
<li>打开阿里云控制台-容器镜像服务-镜像中心-镜像加速器<br><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/1579793979.jpg" alt=""></li>
<li>修改配置文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure>
 添加加速地址<br> <img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/1579794108.jpg" alt=""></li>
<li>重启docker<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 个人总结</title>
    <url>/2020/01/20/2019summarize/</url>
    <content><![CDATA[<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/2019.jpg" alt=""></p>
<a id="more"></a>
<h3 id="奔波的2019"><a href="#奔波的2019" class="headerlink" title="奔波的2019"></a>奔波的2019</h3><p>2019是奔波的一年，从老家到上海到苏州到宁波到杭州。归其原因还是工作，从在上海待了两个月后不计后果裸辞，到一路面试。从上海面到苏州面到宁波面，一路奔波终归在宁波落脚。面试之路是坎坷的，是艰辛的也是最容易迷失自己的。也曾几度想转行，销售，助教，课程顾问，大堂经理都有面试过。当拿到其他行业的offer时总有那么些不甘，最终不考虑转行听取家人建议尝试去周边城市面试。苏州、宁波各去了一个也收到offer，最终选择宁波。从宁波到杭州是因为公司业务拓展。</p>
<h3 id="收获的2019"><a href="#收获的2019" class="headerlink" title="收获的2019"></a>收获的2019</h3><p>尽管2019是奔波的，但也是收获的。重点可以分为态度与经验。从以前的手足无措到现在的井井有条；从以前的程序小白到现在懂得分析源码。优秀谈不上，感谢自己现在的状态，积极向上。</p>
<h3 id="个人展望"><a href="#个人展望" class="headerlink" title="个人展望"></a>个人展望</h3><p>未来职业方向是走技术架构这条路线。</p>
<p>2020个人展望：</p>
<p>系统学习SpringBoot、SpringCloud。</p>
<p>学习Docker，Mysql高级，Srping源码。</p>
<p>感谢</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 按位运算符(&amp;,|,^,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;)</title>
    <url>/2020/01/19/java-bit-operation/</url>
    <content><![CDATA[<h3 id="amp-（按位与）"><a href="#amp-（按位与）" class="headerlink" title="&amp;（按位与）"></a>&amp;（按位与）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：针对二进制，只要有一个为0，就为0。</span><br><span class="line"></span><br><span class="line">2 &amp; 5 &#x3D; 0</span><br><span class="line"></span><br><span class="line">2的二进制：00000000 00000000 00000000 00000010</span><br><span class="line"></span><br><span class="line">5的二进制：00000000 00000000 00000000 00000101</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="（按位或）"><a href="#（按位或）" class="headerlink" title="|（按位或）"></a>|（按位或）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：针对二进制，只要有一个为1，就为1。</span><br><span class="line"></span><br><span class="line">2 | 5 &#x3D; 7</span><br><span class="line"></span><br><span class="line">2的二进制：00000000 00000000 00000000 00000010</span><br><span class="line"></span><br><span class="line">5的二进制：00000000 00000000 00000000 00000101</span><br></pre></td></tr></table></figure>
<h3 id="（按位亦或）"><a href="#（按位亦或）" class="headerlink" title="^（按位亦或）"></a>^（按位亦或）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：针对二进制，相同的为0，不同的为1。</span><br><span class="line"></span><br><span class="line">2 ^ 5 &#x3D; 7</span><br><span class="line"></span><br><span class="line">2的二进制：00000000 00000000 00000000 00000010</span><br><span class="line"></span><br><span class="line">5的二进制：00000000 00000000 00000000 00000101</span><br><span class="line"></span><br><span class="line">2 ^ 3 &#x3D; 1</span><br><span class="line"></span><br><span class="line">2的二进制：00000000 00000000 00000000 00000010</span><br><span class="line"></span><br><span class="line">3的二进制：00000000 00000000 00000000 00000011</span><br></pre></td></tr></table></figure>
<h3 id="（按位非）"><a href="#（按位非）" class="headerlink" title="~（按位非）"></a>~（按位非）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</span><br><span class="line"></span><br><span class="line">~8 &#x3D; -9</span><br><span class="line"></span><br><span class="line">8的二进制：00000000 00000000 00000000 00000100</span><br><span class="line"></span><br><span class="line">~8的二进制：11111111 11111111 11111111 11110111</span><br><span class="line"></span><br><span class="line">因为高位是1，所以该数为负数。&lt;font color &#x3D;&quot;#CC0000&quot;&gt;负数的补码是其绝对值的原码取反，末尾再加1。&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">末尾减1得反码：11111111 11111111 11111111 11110110</span><br><span class="line"></span><br><span class="line">将反码取反：00000000 00000000 00000000 00001001 &#x3D; 9</span><br></pre></td></tr></table></figure>
<h3 id="lt-lt-（向左位移）"><a href="#lt-lt-（向左位移）" class="headerlink" title="&lt;&lt;（向左位移）"></a>&lt;&lt;（向左位移）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：针对二进制，转换成二进制后向左移动3位，后面用0补齐。</span><br><span class="line"></span><br><span class="line">3 &lt;&lt; 1 &#x3D; 6</span><br><span class="line"></span><br><span class="line">3的二进制：00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">3左移后进制数：00000000 00000000 00000000 00000110</span><br></pre></td></tr></table></figure>
<h3 id="gt-gt-（向右位移）"><a href="#gt-gt-（向右位移）" class="headerlink" title="&gt;&gt;（向右位移）"></a>&gt;&gt;（向右位移）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：针对二进制，转换成二进制后向右移动3位。</span><br><span class="line"></span><br><span class="line">3 &gt;&gt; 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">3的二进制：00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">3右移后进制数：00000000 00000000 00000000 00000001</span><br></pre></td></tr></table></figure>
<h3 id="gt-gt-gt-（无符号右移）"><a href="#gt-gt-gt-（无符号右移）" class="headerlink" title="&gt;&gt;&gt;（无符号右移）"></a>&gt;&gt;&gt;（无符号右移）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：忽略符号位，空位都以0补齐。</span><br><span class="line"></span><br><span class="line">-1 &gt;&gt;&gt; 1 &#x3D; 2147483647</span><br><span class="line"></span><br><span class="line">-1的二进制(补码表示法)：11111111 11111111 11111111 11111111</span><br><span class="line"></span><br><span class="line">右移后：01111111 11111111 11111111 11111111</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList 源码分析</title>
    <url>/2020/01/11/SourceCode-LinkedList/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>LinkedList 底层是一个双向链表。是一个直线型的链表结构。</p>
<p>LinkedList 特点：查询慢，增删快。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>LinkedList继承于AbstractSequentialList 实现了List、Deque、Cloneable、java.io.Serializable这些接口。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/LinkedListUML.png" alt=""></p>
<a id="more"></a>
<ul>
<li>继承AbstractSequentialList抽象类：在遍历LinkedList的时候，官方推荐使用迭代器访问。</li>
<li>实现了List接口：提供了相关的添加、删除、修改、遍历等功能。</li>
<li>实现Cloneable：实现clone()方法，实现克隆。</li>
<li>实现java.io.Serializable接口，意味着LinkedList支持序列化，能通过序列化去传输。</li>
<li>实现了Deque接口：提供所有可选的操作。<h3 id="LinkedList-数据结构"><a href="#LinkedList-数据结构" class="headerlink" title="LinkedList 数据结构"></a>LinkedList 数据结构</h3>LinkedList 定义了一个私有内部类Node,用来表示链表数据结构，也就是通过Node来存储元素。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item; <span class="comment">//当前结点存储的元素</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合大小</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * - 头节点</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> * - 固定式：1.头节点为空，尾节点必然为空；2.头节点中上一个节点为空，元素不为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * - 尾节点</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> * - 固定式：1.头节点为空，尾节点必然为空；2.尾节点中下一个节点为空，元素不为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="LinkedList提供了两种构造方法"><a href="#LinkedList提供了两种构造方法" class="headerlink" title="LinkedList提供了两种构造方法"></a>LinkedList提供了两种构造方法</h4><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList()"></a>LinkedList()</h5><p>无参构造:构造一个空列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list.</span></span><br><span class="line"><span class="comment"> * - 构造一个空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LinkedList-Collection-lt-extends-E-gt-c"><a href="#LinkedList-Collection-lt-extends-E-gt-c" class="headerlink" title="LinkedList(Collection&lt;? extends E&gt; c)"></a>LinkedList(Collection&lt;? extends E&gt; c)</h5><p>构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> * - 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment"> * this list, in the order that they are returned by the specified</span></span><br><span class="line"><span class="comment"> * collection's iterator.  The behavior of this operation is undefined if</span></span><br><span class="line"><span class="comment"> * the specified collection is modified while the operation is in</span></span><br><span class="line"><span class="comment"> * progress.  (Note that this will occur if the specified collection is</span></span><br><span class="line"><span class="comment"> * this list, and it's nonempty.)</span></span><br><span class="line"><span class="comment"> * - 将指定集合中的所有元素按照该 collection 的迭代器返回它们的顺序追加到此列表的末尾。如果在操作过程中修改了指定的集合，则此操作的行为未定义。(注意，如果指定的集合是这个列表，并且它不是空的，则会发生这种情况。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment"> * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment"> * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment"> * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment"> * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment"> * specified collection's iterator.</span></span><br><span class="line"><span class="comment"> * - 从指定位置开始，将指定集合中的所有元素插入此列表。将当前位于该位置的元素(如果有)和任何后续元素向右移动(增加它们的索引)。新元素将按照指定集合的迭代器返回它们的顺序出现在列表中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which to insert the first element</span></span><br><span class="line"><span class="comment"> *              from the specified collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否月结</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 集合转换数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 集合长度为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pred：指代待添加节点的前一个节点。</span></span><br><span class="line">    <span class="comment">// succ：指代添加节点的位置。</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">// index == size：待添加的元素永远在最后</span></span><br><span class="line">    <span class="comment">// index != size：先获取指定索引对应的Node节点，在把Node节点赋值给Pred</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// node(index)：获取指定索引对应的Node节点</span></span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="comment">//  @SuppressWarnings("unchecked")</span></span><br><span class="line">        <span class="comment">// 告诉编译器忽略 unchecked 警告信息</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// pred == null：头节点</span></span><br><span class="line">        <span class="comment">// pred != null：非头节点，上一个节点，指向下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// succ == null：表示新添加的元素，是最后一个元素。</span></span><br><span class="line">    <span class="comment">// succ != null：新添加的元素不是最后一个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新长度</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="comment">// 修改的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* - 检查索引是否越界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tells if the argument is the index of a valid position for an</span></span><br><span class="line"><span class="comment"> * iterator or an add operation.</span></span><br><span class="line"><span class="comment"> * - 检查索引是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> * - 返回指定元素索引处的(非空)节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 二分法：判断是在前一半还是在后一半,尽量提高效率。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><h4 id="linkFirst-E-e"><a href="#linkFirst-E-e" class="headerlink" title="linkFirst(E e)"></a>linkFirst(E e)</h4><p>设置头节点元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as first element.</span></span><br><span class="line"><span class="comment"> * - 设置头节点元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：新建节点赋值给头节点，判断旧头节点是否为空，若为空赋值给尾节点；若不为空把旧头节点的上一个节点指向头节点。</p>
</blockquote>
<h4 id="addFirst-E-e"><a href="#addFirst-E-e" class="headerlink" title="addFirst(E e)"></a>addFirst(E e)</h4><p>将该元素插入此列表的头部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：内部调用linkFirst()。</p>
</blockquote>
<h4 id="linkLast-E-e"><a href="#linkLast-E-e" class="headerlink" title="linkLast(E e)"></a>linkLast(E e)</h4><p>设置尾节点元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> * - 设置为节点元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：新建节点赋值给尾节点，判断旧尾节点是否为空，若为空表示该集合为空，没有头节点；若不为空把旧尾节点的下一个节点指向尾节点。</p>
</blockquote>
<h4 id="addLast-E-e"><a href="#addLast-E-e" class="headerlink" title="addLast(E e)"></a>addLast(E e)</h4><p>将该元素插入到此列表的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：内部调用linkLast()。</p>
</blockquote>
<h4 id="linkBefore-E-e-Node-succ"><a href="#linkBefore-E-e-Node-succ" class="headerlink" title="linkBefore(E e, Node succ)"></a>linkBefore(E e, Node<E> succ)</h4><p>在非空节点之前插入元素e。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> * - 在非空节点之前插入元素e。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：新建一个节点元素，将上一个节点指向当前节点，将当前旧节点指向新节点。</p>
</blockquote>
<h4 id="unlinkFirst-Node-f"><a href="#unlinkFirst-Node-f" class="headerlink" title="unlinkFirst(Node f)"></a>unlinkFirst(Node<E> f)</h4><p>删除头节点,并且返回删除的节点的值,使用该方法的前提是参数f是头节点，而且f不能为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment"> * - 删除头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：头节点置空，把下一节点设置为头节点，若下一节点为空，则尾节点为空。</p>
</blockquote>
<h4 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst()"></a>removeFirst()</h4><p>删除头节点,并且返回删除的节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment"> * - 删除头节点,并且返回删除的节点的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：该方法内部调用unlinkFirst()。</p>
</blockquote>
<h4 id="unlinkLast-Node-l"><a href="#unlinkLast-Node-l" class="headerlink" title="unlinkLast(Node l)"></a>unlinkLast(Node<E> l)</h4><p>删除尾节点，并且返回删除节点的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null last node l.</span></span><br><span class="line"><span class="comment"> * - 删除尾节点，并且返回尾节点的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：尾节点置空，把上一节点设置为尾节点，若上一节点为空，则头节点为空。</p>
</blockquote>
<h4 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast()"></a>removeLast()</h4><p>删除指定节点，该节点不为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Removes and returns the last element from this list.</span></span><br><span class="line"><span class="comment">  * - 删除指定节点，该节点不为空。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the last element from this list</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">     <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：该方法内部调用unlinkLast()。</p>
</blockquote>
<h4 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink(Node x)"></a>unlink(Node<E> x)</h4><p>删除指定节点，该节点不为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment"> * - 删除指定节点，该节点不为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：将该节点置空，需要判断是头节点还是尾节点。</p>
</blockquote>
<h4 id="getFirst"><a href="#getFirst" class="headerlink" title="getFirst()"></a>getFirst()</h4><p>获取头节点元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> * - 返回头节点元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：若头节点为空，抛出NoSuchElementException。</p>
</blockquote>
<h4 id="getLast"><a href="#getLast" class="headerlink" title="getLast()"></a>getLast()</h4><p>获取尾节点元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the last element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the last element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：若尾节点为空，抛出NoSuchElementException。</p>
</blockquote>
<h4 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h4><p>判断是否包含某一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this list contains the specified element.</span></span><br><span class="line"><span class="comment"> * More formally, returns &#123;<span class="doctag">@code</span> true&#125; if and only if this list contains</span></span><br><span class="line"><span class="comment"> * at least one element &#123;<span class="doctag">@code</span> e&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ? e==null : o.equals(e))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * - 如果此列表包含指定的元素，则返回true。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this list is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> * - 返回该列表中指定元素第一次出现的索引，如果该列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the first occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：循环遍历每个节点，判断是否存在，若存在则返回ture。</p>
</blockquote>
<h4 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf(Object o)"></a>lastIndexOf(Object o)</h4><p>获取指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> * - 获取指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to search for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the index of the last occurrence of the specified element in</span></span><br><span class="line"><span class="comment"> *         this list, or -1 if this list does not contain the element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：循环遍历链表，判断元素是否存在。</p>
</blockquote>
<h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><p>检索头节点，但不删除头节点。返回头节点元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> * - 检索头节点，但不删除头节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &#123;<span class="doctag">@code</span> null&#125; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其他方法不做阐述，看到这里再看其他方法基本都能看懂。</p>
</blockquote>
]]></content>
      <categories>
        <category>LinkedList 源码</category>
      </categories>
      <tags>
        <tag>List 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>String equals()方法 源码分析</title>
    <url>/2020/01/06/String-equals/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ==:比较的引用类型，比较的是地址值是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123; <span class="comment">//地址值相等，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// instanceOf判断一个对象是不是某个类型的实例</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 比较每一个元素，只要有一个元素不想等 返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>总结：String equals()方法思路：先比较地址值是否相等，在比较字符串的长度是否相等，最后对每个字符做一一对应比较。</p>
</blockquote>
]]></content>
      <categories>
        <category>String.equls() 源码</category>
      </categories>
      <tags>
        <tag>String 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList 源码分析</title>
    <url>/2020/01/02/SourceCode-ArrayList/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>ArrayList继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。如下图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/arraylist_jiegou.png" alt="ArrayList结构图"></p>
<a id="more"></a>
<ul>
<li>ArrayList 继承了AbstractList，实现了List。AbstractList、List提供了相关的添加、删除、修改、遍历等功能。</li>
<li>ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。在ArrayList中，我们即可以通过元素的序号快速获取元素对象,这就是快速随机访问。</li>
<li>ArrayList 实现了Cloneable接口，实现clone()，实现克隆。</li>
<li>ArrayList 实现java.io.Serializable接口，意味着ArrayList支持序列化，能通过序列化去传输。</li>
</ul>
<blockquote>
<p>扩展：ArrayList和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector。</p>
</blockquote>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> * 默认初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> * 空数组，当用户创建空实例时，返回该数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> * 空数组实例</span></span><br><span class="line"><span class="comment"> * - 当用户没有指定 ArrayList 的容量时(即调用无参构造函数)，返回的是该数组==&gt;刚创建一个 ArrayList 时，其内数据量为 0。</span></span><br><span class="line"><span class="comment"> * - 当用户第一次添加元素时，该数组将会扩容，变成默认容量为 10(DEFAULT_CAPACITY) 的一个数组===&gt;通过  ensureCapacityInternal() 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> * 数组对象</span></span><br><span class="line"><span class="comment"> * - 当前数据对象存放地方</span></span><br><span class="line"><span class="comment"> * - 当前对象不参与序列化</span></span><br><span class="line"><span class="comment"> * - transient 关键字最主要的作用就是当序列化时，被transient修饰的内容将不会被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> * 数组中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个列表在结构上被修改的次数。结构修改是指改变列表的大小，或者以一种正在进行的迭代可能会保留不正确结果的方式扰乱列表。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：size和elementData.length是不相同的。size是指当前集合中存在的元素个数，elementData.length是指当前集合指定的容量大小例如，如果我们ArrayList()时，ArrayList只是给我们默认的elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA,此时只是空数组，只有第一次add时才默认数组的大小为DEFAULT_CAPACITY=10 ，此时elementData.length=10,而size=0</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="ArrayList提供了三种构造方法："><a href="#ArrayList提供了三种构造方法：" class="headerlink" title="ArrayList提供了三种构造方法："></a>ArrayList提供了三种构造方法：</h4><h5 id="ArrayList-int-initialCapacity"><a href="#ArrayList-int-initialCapacity" class="headerlink" title="ArrayList(int initialCapacity)"></a>ArrayList(int initialCapacity)</h5><p>构造一个指定容量的ArrayList。这是一个带初始容量大小的有参构造函数。</p>
<ul>
<li>初始容量&gt;0：返回指定容量的大小</li>
<li>初始容量=0：返回空数组</li>
<li>初始容量&lt;0：抛出异常 IllegalArgumentException<!-- more -->
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> * - 构造一个指定容量的ArrayList。这是一个带初始容量大小的有参构造函数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * - 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> * - 如果指定的初始容量为负，抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList()"></a>ArrayList()</h5><p>无参构造方法，创建ArrayList对象的时候不传入参数，则使用此无参构造方法创建ArrayList对象。从前面知道DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的Object[]，给到elementData进行初始化，elementData也是个Object[]类型。<font color ="#CC0000">当有元素进行第一次添加 add() 时，elementData将会变成默认的长度10。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> * - 无参构造方法，创建ArrayList对象的时候不传入参数，则使用此无参构造方法创建ArrayList对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：默认容量为10，调用无参构造此时的容量0，当第一次调用 add() 方法时才进行扩容为10。    </p>
</blockquote>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/new_arraylist.png" alt=""></p>
<h5 id="ArrayList-Collection-lt-extends-E-gt-c"><a href="#ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a>ArrayList(Collection&lt;? extends E&gt; c)</h5><p>构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</p>
<ul>
<li>将 Collection 对象转换成数组并赋值给 elementData。</li>
<li>判断数组大小是否等于0，将空数组 EMPTY_ELEMENTDATA 赋值给 elementData。</li>
<li>如果size的值大于0，则执行Arrays.copy方法，把collection对象的内容(可以理解为深拷贝)拷贝到elementData中。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> * - 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * - 放入此列表的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> * - 如果集合为空，抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            // <span class="title">copyOf</span>(要复制的数组,要返回的副本的长度,要返回的副本的类)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="comment">// 将空数组 EMPTY_ELEMENTDATA 赋值给 elementData。</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>总结：ArrayList 构造方法就是初始化存储数据容器。存储数据容器其本质就是数组，在ArrayList中叫elementData。</p>
</blockquote>
<h3 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h5><p>将指定的元素添加此集合的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> * - 将指定的元素添加此集合的末尾。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查数组容量，不够，容器+1，</span></span><br><span class="line">    <span class="comment">// 注意：只+1，因为add()一次只添加一个元素，并且也能确保资源不被浪费。</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//添加对象，自增size 等同于 elementData[size]; size++;</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查数组容量，不够扩容。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 则取 DEFAULT_CAPACITY 和 minCapacity 的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数组容量，不够扩容。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//最小容量 &gt; 数组长度 = 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment"> * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment"> * - 数组扩容，以确保它至少可以容纳由最小容量参数指定的元素数量。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// &gt;&gt;：表示右移，如果该数为正，则高位补0，若为负数，则高位补1</span></span><br><span class="line">    <span class="comment">// eg : 10 的二进制(1010) 右移 变成 0101(十进制5)，所以扩容是1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 拷贝数组，改变容量大小。</span></span><br><span class="line">    <span class="comment">// Arrays.copyof(原数组，新的数组长度)</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行大容量分配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果minCapacity&lt;0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 如果想要的容量大于MAX_ARRAY_SIZE，则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/add_1.png" alt=""></p>
<ol>
<li>第一次调用add方法流程分析<ol>
<li>调用 add() ,此时 size=0 ,size+1=1;</li>
<li>调用 ensureCapacityInternal(minCapacity) ,此时 minCapacity=1;</li>
<li>调用 calculateCapacity(elementData,minCapacity) ,此时 minCapacity=1 ,elementData={}, DEFAULT_CAPACITY=10 ,DEFAULTCAPACITY_EMPTY_ELEMENTDATA={};</li>
<li>因为 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA 所以取 DEFAULT_CAPACITY ,minCapacity两数最大值 DEFAULT_CAPACITY;</li>
<li>返回 ensureCapacityInternal后,调用 ensureExplicitCapacity(minCapacity) ,此时 minCapacity=10, elementData.length=0;</li>
<li>因为 minCapacity - elementData.length &gt; 0调用 grow();</li>
<li>先扩容 newCapacity = newCapacity + ( newCapacity &gt;&gt; 1 )，判断 newCapacity - minCapacity &lt; 0，所以 newCapacity = minCapacity = 10;</li>
<li>拷贝数组，改变容量大小;</li>
<li>一并返回到 add(),添加对象，自增size;</li>
</ol>
</li>
</ol>
<p><img src="https://images-1259173443.cos.ap-chengdu.myqcloud.com/add_2.jpg" alt=""></p>
<ol start="2">
<li>第二次扩容：第二次扩容是指当前集合中已经存在10(默认容量10)个元素后，继续添加第11个元素。<ol>
<li>调用 add() ,此时 size=10 ,size+1=11;</li>
<li>调用 ensureCapacityInternal(minCapacity) ,此时 minCapacity=11;</li>
<li>调用 calculateCapacity(elementData,minCapacity) ,此时 minCapacity=11 ,elementData.length=10, DEFAULT_CAPACITY=10 ,DEFAULTCAPACITY_EMPTY_ELEMENTDATA.length=0;</li>
<li>因为 elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA ,所以取 minCapacity=11;</li>
<li>返回 ensureCapacityInternal 后,调用 ensureExplicitCapacity(minCapacity) ,此时 minCapacity=11 ,elementData.length=10;</li>
<li>因为 minCapacity - elementData.length &gt; 0 调用 grow();</li>
<li>先扩容 newCapacity = newCapacity + ( newCapacity &gt;&gt; 1 ) ，判断 newCapacity - minCapacity &gt; 0，所以 newCapacity = newCapacity = 15;</li>
<li>拷贝数组，改变容量大小;</li>
<li>一并返回到add(),添加对象，自增size;</li>
</ol>
</li>
</ol>
<h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><p>指定元素插入到列表中的指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> * - 将指定元素插入到列表中的指定位置。将当前位于该位置的元素(如果有)和任何后续元素向右移动(将一个元素添加到它们的索引中)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * - 要插入指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * - 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * - 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 检查数组容量，不够，扩容</span></span><br><span class="line">    <span class="comment">// 注意：只+1，因为add()一次只添加一个元素，并且也能确保资源不被浪费。</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// System.arraycopy(源数组，源数组起始索引，目标数组，目标数组起始索引，要拷贝的长度)</span></span><br><span class="line">    <span class="comment">// 主要思想：将当前位于该位置的元素(如果有)和任何后续元素向右移动(将一个元素添加到它们的索引中)。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 指定索引位置赋值   </span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 大小+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A version of rangeCheck used by add and addAll.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要插入的索引位置不能小于0，不能大于size</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：add(int index, E element)先检查索引是否越界，再判断是否需要扩容，再将需要右移的元素右移，最后赋值，修改大小。</p>
</blockquote>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><p>删除列表中指定位置的元素。将后续所有元素向左移动(从它们的索引中减去1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).</span></span><br><span class="line"><span class="comment"> * - 删除列表中指定位置的元素。将后续所有元素向左移动(从它们的索引中减去1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment"> * - 指定要删除的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment"> * - 删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * - 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要思想：</span></span><br><span class="line">    <span class="comment">// - 1. 先计算出需要左移的元素长度</span></span><br><span class="line">    <span class="comment">// - 2. 将后续所有元素向左移动(从它们的索引中减去1)。</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// System.arraycopy(源数组，源数组起始索引，目标数组，目标数组起始索引，要拷贝的长度)</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 左移后，将最后一个元素至空</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">// 返回删除的元素值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if the given index is in range.  If not, throws an appropriate</span></span><br><span class="line"><span class="comment"> * runtime exception.  This method does *not* check if the index is</span></span><br><span class="line"><span class="comment"> * negative: It is always used immediately prior to an array access,</span></span><br><span class="line"><span class="comment"> * which throws an ArrayIndexOutOfBoundsException if index is negative.</span></span><br><span class="line"><span class="comment"> * - 检查给定的索引是否在范围内。如果不是，则抛出适当的运行时异常。该方法不*not*检查索引是否为负数:它总是在数组访问之前使用，如果索引为负数，则会抛出ArrayIndexOutOfBoundsException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an IndexOutOfBoundsException detail message.</span></span><br><span class="line"><span class="comment"> * Of the many possible refactorings of the error handling code,</span></span><br><span class="line"><span class="comment"> * this "outlining" performs best with both server and client VMs.</span></span><br><span class="line"><span class="comment"> * - 构造一个角标越界提示信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定索引的值</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：remove(int index)先检查索引是否越界，然后计算出要左移的元素长度，最后左移。将最后一个元素至空。</p>
</blockquote>
<h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><p>从该列表中删除指定元素的第一个匹配项(如果存在)。如果列表不包含该元素，它将保持不变。确切的说，删除索引最小的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If the list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * - 从该列表中删除指定元素的第一个匹配项(如果存在)。如果列表不包含该元素，它将保持不变。确切的说，删除索引最小的元素</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ?  get(i) == null : o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * - 要删除的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> * - 返回true or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> * - 私有移除方法，该方法跳过边界检查且不返回被移除的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 计算要左移元素的长度</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// System.arraycopy(源数组，源数组起始索引，目标数组，目标数组起始索引，要拷贝的长度)</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">// 左移后，将最后一个元素至空</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：remove(Object o)：删除指定元素，不用检查索引越界。此方法只删除索引值最小的元素。</p>
</blockquote>
<h4 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get(int index)"></a>get(int index)</h4><p>返回列表中指定位置的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * - 返回列表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 获取指定索引上的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h4><p>将列表中指定位置的元素替换为指定元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with</span></span><br><span class="line"><span class="comment"> * the specified element.</span></span><br><span class="line"><span class="comment"> * - 将列表中指定位置的元素替换为指定元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to replace</span></span><br><span class="line"><span class="comment"> * - 要替换的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be stored at the specified position</span></span><br><span class="line"><span class="comment"> * - 元素存储在指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the element previously at the specified position</span></span><br><span class="line"><span class="comment"> * - 先前位于指定位置的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 获取指定位置的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 替换指定位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回被替换的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf(Object o)"></a>indexOf(Object o)</h4><p>返回该列表中指定元素第一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最低的索引的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * - 返回该列表中指定元素第一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最低的索引的元素</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf(Object o)"></a>lastIndexOf(Object o)</h4><p>返回指定元素最后一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最高的索引的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment"> * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment"> * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * - 返回指定元素最后一次出现的索引，如果该列表不包含该元素，则返回-1。确切的说，返回最高的索引的元素</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>从列表中删除所有元素。该调用返回后，列表将为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> * - 从列表中删除所有元素。该调用返回后，列表将为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ArrayList 源码</category>
      </categories>
      <tags>
        <tag>List 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>IllegalArgumentException：argument type mismatch</title>
    <url>/2019/12/30/JavaBug-IdAutoException/</url>
    <content><![CDATA[<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nested exception is org.apache.ibatis.reflection.ReflectionException: Could not set property <span class="string">'id'</span> of <span class="string">'class com.wzq.test.demo.entity.Fee'</span> with value <span class="string">'1211518556674199553'</span>Cause:java.lang.IllegalArgumentException: argument type mismatch</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h4><pre><code>添加不传ID使用数据库中的自增。提示类型转换错误,Long转换Integer错误,原因ID初始化值过大转化成Integer错误。</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h4><pre><code>设置ID的初始化值:ALTER TABLE TABLENAME AUTO_INCREMENT=1;
@TableId(value = &quot;id&quot;, type = IdType.AUTO)
private Integer id;</code></pre>]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 Strams简单使用</title>
    <url>/2019/12/26/JDK8_strams/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><hr>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。<br>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。<br>Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的上进行操作处理， 比如筛选， 排序，聚合等。<br>元素流在管道中经过中间的一系列操作（intermediate operation）和处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<a id="more"></a>
<h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 </li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><ol>
<li>场景一：过滤集合内的元素<blockquote>
<p>JDK8之前 对集合进行过滤</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; strList = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</span><br><span class="line">            System.out.println(<span class="string">"初始化数据： "</span> + strList);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * JDK8之前 对集合进行过滤</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//过滤掉小写字母c</span></span><br><span class="line">            strList = getFilterOutput(strList, <span class="string">"c"</span>);</span><br><span class="line">            System.out.println(<span class="string">"过滤小写字母c后数据："</span>+strList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 过滤掉小写字母c</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> strList   集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> strFilter 需要过滤的字符</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getFilterOutput</span><span class="params">(List&lt;String&gt; strList, String strFilter)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.equals(<span class="string">"c"</span>)) &#123;</span><br><span class="line">                    filterList.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filterList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8 后 使用Streams中 filter() and collect() 方法进行过滤数据和收集数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>);</span><br><span class="line">        System.out.println(<span class="string">"初始化数据： "</span> + strList);</span><br><span class="line">        strList = strList.stream().filter(s -&gt;</span><br><span class="line">                !s.equals(<span class="string">"c"</span>)</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">"过滤小写字母c后数据："</span> + strList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 strList.stream() : 将List转换为stram<br> filter() : 过滤并返回<br> collect() : 将返回的结果转换为List</li>
<li>场景二：通过username获取对象<blockquote>
<p>JDK8 之前 通过username获取对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="string">"password1"</span>), <span class="keyword">new</span> User(<span class="string">"username2"</span>, <span class="string">"password2"</span>), <span class="keyword">new</span> User(<span class="string">"username3"</span>, <span class="string">"password3"</span>));</span><br><span class="line">        User user = getFilterUser(userList, <span class="string">"username2"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过username获取对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userList</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getFilterUser</span><span class="params">(List&lt;User&gt; userList,String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(user.getUsername()))&#123;</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8 使用Streams中 filter(), findAny() and orElse() 方法进行过滤数据和收集数据</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = Arrays.asList(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="string">"password1"</span>), <span class="keyword">new</span> User(<span class="string">"username2"</span>, <span class="string">"password2"</span>), <span class="keyword">new</span> User(<span class="string">"username3"</span>, <span class="string">"password3"</span>));</span><br><span class="line">        User user = userList.stream().filter(username -&gt; <span class="string">"username2"</span>.equals(username)).findAny().orElse(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>filter() : 过滤并返回
findAny() : 若有返回参数，直接返回
orElse() : 若没有返回参数，返回null</code></pre><ol start="3">
<li>场景三：从对象集合中取出某个字段的集合<blockquote>
<p>JDK 8 之前从对象集合中取出某个字段的集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义list集合</span></span><br><span class="line">        List&lt;admin&gt; list = Arrays.asList(<span class="keyword">new</span> admin(<span class="number">1</span>, <span class="string">"周杰"</span>), <span class="keyword">new</span> admin(<span class="number">2</span>, <span class="string">"周捷"</span>), <span class="keyword">new</span> admin(<span class="number">3</span>, <span class="string">"周洁"</span>));</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (admin admin : list) &#123;</span><br><span class="line">            names.add(admin.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">admin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK8 使用Streams中 map(), collect()方法进行过滤数据和收集数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义list集合</span></span><br><span class="line">        List&lt;admin&gt; list = Arrays.asList(<span class="keyword">new</span> admin(<span class="number">1</span>, <span class="string">"周杰"</span>), <span class="keyword">new</span> admin(<span class="number">2</span>, <span class="string">"周捷"</span>), <span class="keyword">new</span> admin(<span class="number">3</span>, <span class="string">"周洁"</span>));</span><br><span class="line">        <span class="comment">//从list集合中，取出字段name的列表</span></span><br><span class="line">        List&lt;String&gt; names = list.stream().map(p -&gt; p.getName()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">admin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">admin</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 之 单例模式</title>
    <url>/2019/12/26/designMode_singleton/</url>
    <content><![CDATA[<h4 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h4><p>&ensp;&ensp;&ensp;&ensp;Ensure a class has only one instance,and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
<h4 id="一个皇帝原则"><a href="#一个皇帝原则" class="headerlink" title="一个皇帝原则"></a>一个皇帝原则</h4><p>&ensp;&ensp;&ensp;&ensp;皇帝每天要上朝接待臣子、处理政务，臣子每天要叩拜皇帝，皇帝只能有一个，也就是一个类只能产生一个对象，该怎么实现呢？对象产生是通过new关键字完成的（当然也有其他方式，比如对象拷贝、反射等），这个怎么控制呀，但是大家别忘记了构造函数，使用new关键字创建对象时，都会根据输入的参数调用相应的构造函数，如果我们把构造函数设置为private私有访问权限不就可以禁止外部创建对象了吗？臣子叩拜唯一皇帝的过程如类图7-1所示。 </p>
<a id="more"></a>
<p><img src="https://img1.doubanio.com/view/ark_works_pic/common-largeshow/public/87117.jpg" alt="7-1"></p>
<p>&ensp;&ensp;&ensp;&ensp;图7-1 臣子叩拜皇帝类图</p>
<p>&ensp;&ensp;&ensp;&ensp;只有两个类，Emperor代表皇帝类，Minister代表臣子类，关联到皇帝类非常简单。Emperor如代码清单7-1所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-1 皇帝类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Emperor emperor = <span class="keyword">new</span> Emperor();<span class="comment">//初始化一个皇帝</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//世俗和道德约束你，目的就是不希望产生第二个皇帝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//皇帝发话了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我就是皇帝Jacob..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象，而Emperor自己则可以new一个对象出来，其他类对该类的访问都可以通过getInstance获得同一个对象。<br>&ensp;&ensp;&ensp;&ensp;皇帝有了，臣子要出场，其类如代码清单7-2所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-2 臣子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码清单7-2 臣子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day=<span class="number">0</span>;day&lt;<span class="number">3</span>;day++)&#123;</span><br><span class="line">            Emperor emperor = Emperor.getInstance();</span><br><span class="line">            <span class="comment">//打印一下地址,判断是否相同</span></span><br><span class="line">            System.out.println(emperor);</span><br><span class="line">            emperor.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">臣子参拜皇帝的运行结果如下所示。</span><br><span class="line">我就是皇帝Jacob...</span><br><span class="line">cn.wzq.design.mode.singleton.Emperor@<span class="number">299</span>a06ac</span><br><span class="line">我就是皇帝Jacob...</span><br><span class="line">cn.wzq.design.mode.singleton.Emperor@<span class="number">299</span>a06ac</span><br><span class="line">我就是皇帝Jacob...</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;臣子天天要上朝参见皇帝，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，老熟人了，容易讲话，这就是单例模式。</p>
<h4 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h4><p>&ensp;&ensp;&ensp;&ensp;单例模式（Singleton Pattern）是一个比较简单的模式，其定义如下：<br>&ensp;&ensp;&ensp;&ensp;Ensure a class has only one instance,and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）</p>
<p>&ensp;&ensp;&ensp;&ensp;单例模式的通用类图如图7-2所示</p>
<p><img src="https://img9.doubanio.com/view/ark_works_pic/common-largeshow/public/87326.jpg" alt="7-2"></p>
<p>&ensp;&ensp;&ensp;&ensp;如图7-2 单例模式通用类</p>
<p>&ensp;&ensp;&ensp;&ensp;Singleton类称为单例类，通过使用private的构造函数确保了在一个应用中只产生一个实例，并且是自行实例化的（在Singleton中自己使用new Singleton（））。</p>
<p>&ensp;&ensp;&ensp;&ensp;单例模式的通用源代码如代码清单7-3所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-3 单例模式通用代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Emperor emperor = <span class="keyword">new</span> Emperor();<span class="comment">//初始化一个皇帝</span></span><br><span class="line">    <span class="comment">//限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emperor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"皇帝要睡觉了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h4><h5 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h5><ul>
<li><p>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</p>
</li>
<li><p>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。</p>
</li>
<li><p>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</p>
</li>
<li><p>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</p>
<h5 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h5></li>
<li><p>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。</p>
</li>
<li><p>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</p>
</li>
<li><p>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</p>
<h5 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h5><p>&ensp;&ensp;&ensp;&ensp;在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反应”，可以采用单例模式，具体的场景如下：</p>
</li>
<li><p>要求生成唯一序列号的环境；</p>
</li>
<li><p>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</p>
</li>
<li><p>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</p>
</li>
<li><p>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。</p>
<h5 id="单例模式的注意事项"><a href="#单例模式的注意事项" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h5><p>&ensp;&ensp;&ensp;&ensp;首先，在高并发情况下，请注意单例模式的线程同步问题。单例模式有几种不同的实现方式，上面的例子不会出现产生多个实例的情况，但是如代码清单7-4所示的单例模式就需要考虑线程同步。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-4 线程不安全的单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;该单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则可能在内存中出现多个实例，破坏了最初的预期。为什么会出现这种情况呢？如一个线程A执行到singleton=new Singleton（），但还没有获得对象（对象初始化是需要时间的），第二个线程B也在执行，执行到（singleton==null）判断，那么线程B获得判断条件也是为真，于是继续运行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现两个对象！</p>
<p>&ensp;&ensp;&ensp;&ensp;解决线程不安全的方法有很多，可以在getSingleton方法前加synchronized关键字，也可以在getSingleton方法内增加synchronized来实现，但都不是最优秀的单例模式，建议读者使用如代码清单7-3所示的方式（有的书上把代码清单7-3中的单例称为饿汉式单例，在代码清单7-4中增加了synchronized的单例称为懒汉式单例）。</p>
<p>&ensp;&ensp;&ensp;&ensp;其次，需要考虑对象的复制情况。在Java中，对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。在一般情况下，类复制的情况不需要考虑，很少会出现一个单例类会主动要求被复制的情况，解决该问题的最好方法就是单例类不要实现Cloneable接口。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果一个类可以产生多个对象，对象的数量不受限制，则是非常容易实现的，直接使用new关键字就可以了，如果只要有一个对象，使用单例模式就可以了，但是如果要求一个类只能产生两三个对象呢？该怎么实现？我们还以皇帝为例来说明。</p>
<p>&ensp;&ensp;&ensp;&ensp;一般情况下，一个朝代的同一个时代只有一个皇帝，那有没有出现两个皇帝的情况呢？确实有，就出现在明朝，那三国期间的算不算？不算，各自称帝，各有各的地盘，国号不同。大家还记得《石灰吟》这首诗吗？作者是谁？于谦。他是被谁杀死的？明英宗朱祁镇。对，就是那个在土木堡之变中被瓦刺俘虏的皇帝，被俘虏后，他弟弟朱祁钰当上了皇帝，就是明景帝，估计刚当上皇帝乐疯了，忘记把他哥哥朱祁镇升级为太上皇，在那个时期就出现了两个皇帝，这期间的的大臣是非常郁闷的，为什么呀？因为可能出现今天参拜的皇帝和昨天的皇帝不相同，昨天给那个皇帝汇报，今天还要给这个皇帝汇报一遍，该情况的类图如图7-3所示。</p>
<p><img src="https://img3.doubanio.com/view/ark_works_pic/common-largeshow/public/87335.jpg" alt="7-3"></p>
<p>&ensp;&ensp;&ensp;&ensp;图7-3 多个皇帝类</p>
<p>&ensp;&ensp;&ensp;&ensp;这个类图看起来还算简单，但是实现就有点复杂了。Emperor类如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码清单7-5 固定数量的皇帝类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义最多能产生的实例数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxNumOfEmperor = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//定义一个列表，容纳所有的皇帝实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Emperor2&gt; emperorList = <span class="keyword">new</span> ArrayList&lt;Emperor2&gt;();</span><br><span class="line">    <span class="comment">//当前皇帝序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> countNumOfEmperor = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//产生所有的对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNumOfEmperor;i++)&#123;</span><br><span class="line">            emperorList.add(<span class="keyword">new</span> Emperor2(<span class="string">"皇帝"</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//皇帝名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emperor2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        countNumOfEmperor = random.nextInt(maxNumOfEmperor);</span><br><span class="line">        <span class="keyword">return</span> emperorList.get(countNumOfEmperor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(nameList.get(countNumOfEmperor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在Emperor中使用了两个ArrayList分别存储实例和实例变量。当然，如果考虑到线程安全问题可以使用Vector来代替。臣子参拜皇帝的过程如代码清单7-6所示。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码清单7-6 臣子参拜皇帝的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minister2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义5个大臣</span></span><br><span class="line">        <span class="keyword">int</span> ministerNum=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ministerNum;i++) &#123;</span><br><span class="line">            Emperor2 emperor = Emperor2.getInstance();</span><br><span class="line">            System.out.print(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个大臣参拜的是："</span>+emperor);</span><br><span class="line">            emperor.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大臣参拜皇帝的结果如下所示。</span><br><span class="line">第<span class="number">1</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br><span class="line">第<span class="number">2</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br><span class="line">第<span class="number">3</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">6</span>bc168e5皇帝<span class="number">0</span></span><br><span class="line">第<span class="number">4</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">6</span>bc168e5皇帝<span class="number">0</span></span><br><span class="line">第<span class="number">5</span>个大臣参拜的是：cn.wzq.design.mode.singleton.Emperor2@<span class="number">383534</span>aa皇帝<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;看，果然每个大臣参拜的皇帝都可能不一样，大臣们就开始糊涂了，A大臣给皇1帝汇报了一件事情，皇2帝不知道，然后就开始怀疑大臣A是皇1帝的亲信，然后就想办法开始整……<br>这种需要产生固定数量对象的模式就叫做有上限的多例模式，它是单例模式的一种扩展，采用有上限的多例模式，我们可以在设计时决定在内存中有多少个实例，方便系统进行扩展，修正单例可能存在的性能问题，提供系统的响应速度。例如读取文件，我们可以在系统启动时完成初始化工作，在内存中启动固定数量的reader实例，然后在需要读取文件时就可以快速响应。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>&ensp;&ensp;&ensp;&ensp;单例模式是23个模式中比较简单的模式，应用也非常广泛，如在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建出来，什么时候销毁，销毁的时候要如何处理，等等。如果采用非单例模式（Prototype类型），则Bean初始化后的管理交由J2EE容器，Spring容器不再跟踪管理Bean的生命周期。</p>
<p>&ensp;&ensp;&ensp;&ensp;使用单例模式需要注意的一点就是JVM的垃圾回收机制，如果我们的一个单例对象在内存中长久不使用，JVM就认为这个对象是一个垃圾，在CPU资源空闲的情况下该对象会被清理掉，下次再调用时就需要重新产生一个对象。如果我们在应用中使用单例类作为有状态值（如计数器）的管理，则会出现恢复原状的情况，应用就会出现故障。如果确实需要采用单例模式来记录有状态的值，有两种办法可以解决该问题：</p>
<ul>
<li><p>由容器管理单例的生命周期</p>
<p>  Java EE容器或者框架级容器（如Spring）可以让对象长久驻留内存。当然，自行通过管理对象的生命期也是一个可行的办法，既然有那么多的工具提供给我们，为什么不用呢？</p>
</li>
<li><p>状态随时记录</p>
<p>  可以使用异步记录的方式，或者使用观察者模式，记录状态的变化，写入文件或写入数据库中，确保即使单例对象重新初始化也可以从资源环境获得销毁前的数据，避免应用数据丢失。</p>
</li>
</ul>
<h4 id="摘自：《设计模式之禅》-—-秦小波"><a href="#摘自：《设计模式之禅》-—-秦小波" class="headerlink" title="摘自：《设计模式之禅》 — 秦小波"></a>摘自：《设计模式之禅》 — 秦小波</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 方法引用</title>
    <url>/2019/12/25/JDK8_method/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<ul>
<li>方法引用：当要传递给Lambda体的操作，已经有实现的方法了，就可以使用方法引用</li>
<li>方法引用：在Lambda的基础上进一步的简化。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</li>
<li>要求：实现接口的抽象方法体的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</li>
<li>使用操作符 :: 将类（或对象）与方法名分割开来</li>
<li>主要分为下面三种使用情况：<ol>
<li>对象 :: 实例方法名</li>
<li>类 :: 静态方法名</li>
<li>类 :: 实例方法名<a id="more"></a>
<h6 id="场景-模拟发送邮件"><a href="#场景-模拟发送邮件" class="headerlink" title="场景:模拟发送邮件"></a>场景:模拟发送邮件</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"无参构造"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timingSendEamil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticEamil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" static 发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1、JDK8 之前</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> EmailService().timingSendEamil();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2、JDK8 后使用Lambda表达式优化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">new</span> EmailService().timingSendEamil();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3、因为方法引用是在Lambda的基础上进一步的简化,所以使用方法引用进一步优化上面的代码</span></span><br><span class="line"><span class="comment">         * 格式： 实例对象::实例方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EmailService emailService = <span class="keyword">new</span> EmailService();</span><br><span class="line">        <span class="keyword">new</span> Thread(emailService::timingSendEamil).start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4、拆分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runnable runnable = emailService::timingSendEamil;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 5、使用方法引用调用我们的静态方法</span></span><br><span class="line"><span class="comment">         * 格式: 类名::静态方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(EmailService::staticEamil).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6、使用方法引用调用构造方法</span></span><br><span class="line"><span class="comment">         * 格式： 类名::new</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(EmailService::<span class="keyword">new</span>).start();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 Lambda表达式</title>
    <url>/2019/12/25/JDK8_Lambda/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<ul>
<li>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</li>
<li>Lambda 允许把函数作为参数传递进方法中。</li>
<li>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</li>
<li>lambda表达式的重要特征:<ol>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。<a id="more"></a>
</li>
</ol>
</li>
</ul>
<hr>
<h6 id="JDK8-之前调用接口的方式是通过匿名内部类，调用接口中的方法。"><a href="#JDK8-之前调用接口的方式是通过匿名内部类，调用接口中的方法。" class="headerlink" title="JDK8 之前调用接口的方式是通过匿名内部类，调用接口中的方法。"></a>JDK8 之前调用接口的方式是通过匿名内部类，调用接口中的方法。</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface functionInterface = <span class="keyword">new</span> FunctionInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"get方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        functionInterface.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用Lambda表达式调用接口中的方法"><a href="#使用Lambda表达式调用接口中的方法" class="headerlink" title="使用Lambda表达式调用接口中的方法"></a>使用Lambda表达式调用接口中的方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface ft = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"JDK8 Lambda表达式调用：get方法"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        ft.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>() : 表示抽象方法所需的参数列表,(参数1，参数2)<br>-&gt; : 固定格式<br>{} ：表示抽象方法的方法体</p>
</blockquote>
<h6 id="有返回值的Lambda表达式调用方法"><a href="#有返回值的Lambda表达式调用方法" class="headerlink" title="有返回值的Lambda表达式调用方法"></a>有返回值的Lambda表达式调用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface2 functionInterface2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"有返回值的Lambda表达式调用方法"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(functionInterface2.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 优化：有返回值的Lambda表达式调用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        FunctionInterface2 functionInterface3 = () -&gt; <span class="string">"优化：有返回值的Lambda表达式调用方法"</span>;</span><br><span class="line">        System.out.println(functionInterface3.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="有参数，有返回值的Lambda表达式调用方法"><a href="#有参数，有返回值的Lambda表达式调用方法" class="headerlink" title="有参数，有返回值的Lambda表达式调用方法"></a>有参数，有返回值的Lambda表达式调用方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface3</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionInterface3 ft3 = (String s)-&gt; s;</span><br><span class="line">        System.out.println(ft3.get(<span class="string">"有参数，有返回值的Lambda表达式调用方法"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 函数接口</title>
    <url>/2019/12/25/JDK8_FunctionInterface/</url>
    <content><![CDATA[<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><blockquote>
<p>定义:接口中只有唯一的一个抽象方法，该接口就称之为函数接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>@FunctionInterface: <br/><br> JDK 8推出了一个重要的注解@FunctionInterface<br> @FunctionInterface:作用主要用来强制约定一个接口只允许一个抽象方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、使用@FunctionInterface注解后，该接口只能有一个抽象方法，</span></span><br><span class="line">    <span class="comment">//   get2() 方法放开会报错</span></span><br><span class="line">    <span class="comment">//void get2();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数接口中支持 default 和 static 关键字修饰我们的方法，允许存在Object类中equals方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、只有一个方法的接口，默认称之为函数接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、使用@FunctionInterface注解后，该接口只能有一个抽象方法，</span></span><br><span class="line">    <span class="comment">//void get2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、函数接口中支持 default 和 static 关键字修饰我们的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是default修饰的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是static修饰的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、重点：允许存在Object类中equals方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK中存在的函数接口：<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;Runnable:用于创建线程 <br/><br>&nbsp;&nbsp;&nbsp;&nbsp;Comparator:用于比较对象</p>
</blockquote>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8 新特性 之 default关键字</title>
    <url>/2019/12/23/JDK8_default/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<br/></h3><ul>
<li>Jdk1.8之前的接口中只声明方法，方法具体实现应在子类中进行。<br/></li>
<li>Jdk1.8打破了这样的用法：接口中可以实现具体的方法体，只需要加上关键字static或者default修饰即可。<br/><a id="more"></a></li>
</ul>
<ol>
<li><p>default关键字</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    //自定义方法</span><br><span class="line">    void getUsername();</span><br><span class="line">    //默认方法</span><br><span class="line">    default void <span class="function"><span class="title">defaultUsername</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //默认方法,子类重写</span><br><span class="line">    default void <span class="function"><span class="title">overrideDefaultUsername</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">overrideDefaultUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        userService.getUsername();</span><br><span class="line">        userService.defaultUsername();</span><br><span class="line">        userService.overrideDefaultUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"结果打印数据："</span></span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername</span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername</span><br></pre></td></tr></table></figure>
</li>
<li><p>static关键字</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">void getUsername();</span><br><span class="line"></span><br><span class="line">default void <span class="function"><span class="title">defaultUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default void <span class="function"><span class="title">overrideDefaultUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="function"><span class="title">staticUsername</span></span>()&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;staticUsername"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">getUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">overrideDefaultUsername</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">在子类中发现不能重写被static关键字修饰的方法。</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        userService.getUsername();</span><br><span class="line">        userService.defaultUsername();</span><br><span class="line">        userService.overrideDefaultUsername();</span><br><span class="line">        UserService.staticUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"结果打印数据"</span></span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;defaultUsername</span><br><span class="line">UserServiceImpl&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;overrideDefaultUsername</span><br><span class="line">UserService&gt;&gt;&gt;&gt;&gt;&gt;&gt;staticUsername</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结<br>&nbsp;&nbsp;default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. detault关键字修饰的方法称为默认方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 子类可以选择性的是否重写该方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 接口中的default方法通过实例对象来调用<br>&nbsp;&nbsp;static:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. static关键字修饰的方法称为静态方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 子类不能重写该方法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 接口中的静态方法通过接口名.方法名()的方式来</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>JDK8 新特性</tag>
      </tags>
  </entry>
</search>
